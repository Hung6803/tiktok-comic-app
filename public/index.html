<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TikTok Comic Generator üé¨</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
    
    * {
      font-family: 'Nunito', sans-serif;
    }
    
    .gradient-text {
      background: linear-gradient(135deg, #f472b6, #a855f7, #22d3ee);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .glass {
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(71, 85, 105, 0.5);
    }
    
    .gradient-btn {
      background: linear-gradient(135deg, #ec4899, #a855f7, #06b6d4);
    }
    
    .gradient-btn:hover {
      box-shadow: 0 10px 40px rgba(168, 85, 247, 0.4);
    }
    
    .panel-card:hover .regenerate-btn {
      opacity: 1;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }
    
    .float-animation {
      animation: float 6s ease-in-out infinite;
    }
    
    .loading-spinner {
      border: 4px solid rgba(168, 85, 247, 0.3);
      border-top: 4px solid #a855f7;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      height: 8px;
      background: #334155;
      border-radius: 4px;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #a855f7, #06b6d4);
      border-radius: 50%;
      cursor: pointer;
    }

    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900">
  <!-- Animated background -->
  <div class="fixed inset-0 overflow-hidden pointer-events-none">
    <div class="absolute -top-40 -right-40 w-80 h-80 bg-pink-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 float-animation"></div>
    <div class="absolute -bottom-40 -left-40 w-80 h-80 bg-cyan-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 float-animation" style="animation-delay: 2s;"></div>
    <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-96 h-96 bg-purple-500 rounded-full mix-blend-multiply filter blur-3xl opacity-10 float-animation" style="animation-delay: 4s;"></div>
  </div>

  <div id="app" class="relative z-10"></div>

  <!-- Regenerate Modal -->
  <div id="regenerateModal"></div>

  <!-- Ad Regenerate Modal -->
  <div id="adRegenerateModal"></div>

  <!-- Story Library Modal -->
  <div id="storyLibraryModal"></div>

  <script>
    // API Provider Limits
    // Token formula for series outline: episodes * 600 + 2000
    // DeepSeek: (8192 - 2000) / 600 ‚âà 10 safe episodes
    // Gemini: (65536 - 2000) / 600 ‚âà 105 safe episodes
    const API_LIMITS = {
      deepseek: {
        name: 'DeepSeek',
        maxOutputTokens: 8192,
        maxEpisodes: 15,            // Safe limit: ~10, allow up to 15 with warning
        maxPanelsPerEpisode: 25,    // Max cho DeepSeek
        safeEpisodes: 10,           // S·ªë chap an to√†n kh√¥ng b·ªã c·∫Øt
        description: 'DeepSeek - Nhanh, ·ªïn ƒë·ªãnh (t·ªëi ∆∞u ‚â§10 chap)'
      },
      gemini: {
        name: 'Gemini 3 Pro',
        maxOutputTokens: 65536,
        maxEpisodes: 200,           // C√≥ th·ªÉ nhi·ªÅu h∆°n nh·ªù 65k tokens
        maxPanelsPerEpisode: 30,    // Max cho Gemini
        safeEpisodes: 100,          // An to√†n ƒë·∫øn 100 chap
        description: 'Gemini 3 Pro - M·∫°nh m·∫Ω, h·ªó tr·ª£ 100+ chap!'
      }
    };

    // State management
    const state = {
      // API Keys & Provider
      deepseekKey: localStorage.getItem('deepseekKey') || '',
      geminiKey: localStorage.getItem('geminiKey') || '',
      textApiProvider: localStorage.getItem('textApiProvider') || 'deepseek', // 'deepseek' or 'gemini'
      hybridMode: localStorage.getItem('hybridMode') === 'true', // Gemini for outline + DeepSeek for panels
      showApiSetup: true,

      // Story settings
      genre: 'romance',
      artStyle: 'manga',
      colorMode: localStorage.getItem('colorMode') || 'full_color', // full_color, limited_color, black_white, sepia
      lightingStyle: localStorage.getItem('lightingStyle') || 'natural', // natural, dramatic, soft, neon, golden
      storyPrompt: '',
      storyLength: 'medium', // short, medium, long
      panelCount: 8,
      emotionalIntensity: 'balanced', // subtle, balanced, intense
      generationMode: 'two-stage', // 'single-stage' or 'two-stage'

      // Episode/Series Mode
      storyMode: 'single', // 'single' or 'series'
      seriesOutline: null, // Full series arc roadmap (high-level)
      episodes: [], // Array of generated episodes with full panel data
      currentEpisodeIndex: 0, // Which episode we're viewing/generating
      episodesPerSeries: 10, // M·∫∑c ƒë·ªãnh 10 chap (an to√†n cho DeepSeek, tƒÉng v·ªõi Gemini)
      panelsPerEpisode: 15, // 15 panels/chap - ng·∫Øn g·ªçn, d·ªÖ ƒë·ªçc tr√™n mobile

      // Characters
      characters: [],
      newCharName: '',
      newCharDesc: '',

      // Main navigation tab
      activeTab: 'story', // 'story' or 'ads'

      // Generated content
      storyData: null,
      storyOutline: null, // For two-stage: outline with characters + panel summaries
      panels: [],
      detailedPanels: [], // Store panel prompts before image generation (for review)
      currentStep: 'idle', // idle, outline, story, panel-details, images, complete, error, awaiting-approval
      error: '',
      progress: { current: 0, total: 0 },
      loadingMessage: '', // Custom loading message for chunked generation
      promptsReady: false, // True when prompts generated and waiting for approval

      // Regeneration
      showRegenerateModal: false,
      regeneratePanelIndex: null,
      regenerateModification: '',

      // Failed batches tracking (for retry)
      failedBatches: [], // [{startEp, endEp, error}]
      isRetrying: false,

      // Episode list pagination
      episodeListPage: 0, // Current page (0-indexed)
      episodesPerPage: 9, // 3x3 grid

      // Story Library (saved stories)
      currentStoryId: null, // ID of currently loaded story
      savedStories: [], // List of saved stories (loaded from localStorage)
      showStoryLibrary: false, // Show/hide story library modal

      // Ad Generator Tab
      adGeneratorStoryId: null, // Story ID for ad generator
      adProduct: { name: '', description: '', context: '', image: null }, // Product for ad generation
      generatedAdPanels: [], // Generated ad panels
      adGenerating: false, // Loading state for ad generation

      // Ad Panel Regeneration
      showAdRegenerateModal: false,
      regenerateAdPanelIndex: null,
      adRegenerateModification: ''
    };

    // ===========================================
    // STORY LIBRARY - Server-based Storage
    // ===========================================

    // Generate unique ID for story
    function generateStoryId() {
      return 'story_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Load all saved stories from server
    async function loadSavedStories() {
      try {
        console.log('üìö Loading stories from server...');
        const response = await fetch('/api/stories');
        const data = await response.json();

        if (data.success) {
          state.savedStories = data.stories || [];
          console.log(`‚úÖ Loaded ${state.savedStories.length} stories from server`);
        } else {
          console.error('‚ùå Server error:', data.error);
          state.savedStories = [];
        }
      } catch (e) {
        console.error('‚ùå Error loading stories from server:', e);
        state.savedStories = [];
      }
      render();
    }

    // Save story to server
    async function saveStoryToServer(storyData) {
      try {
        const response = await fetch('/api/stories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(storyData)
        });
        const data = await response.json();
        return data.success;
      } catch (e) {
        console.error('‚ùå Error saving story to server:', e);
        return false;
      }
    }

    // Save current story
    async function saveCurrentStory(autoSave = false) {
      if (!state.seriesOutline && !state.storyData) {
        if (!autoSave) alert('Ch∆∞a c√≥ truy·ªán ƒë·ªÉ l∆∞u!');
        return null;
      }

      const storyId = state.currentStoryId || generateStoryId();
      const storyName = state.seriesOutline?.series_title || state.storyData?.title || 'Untitled Story';

      const storyData = {
        id: storyId,
        name: storyName,
        createdAt: state.currentStoryId ?
          (state.savedStories.find(s => s.id === storyId)?.createdAt || Date.now()) :
          Date.now(),
        updatedAt: Date.now(),

        // Settings
        genre: state.genre,
        artStyle: state.artStyle,
        colorMode: state.colorMode,
        lightingStyle: state.lightingStyle,
        storyMode: state.storyMode,
        storyPrompt: state.storyPrompt,
        emotionalIntensity: state.emotionalIntensity,
        episodesPerSeries: state.episodesPerSeries,
        panelsPerEpisode: state.panelsPerEpisode,

        // Characters (user-defined)
        characters: state.characters,

        // Story content
        seriesOutline: state.seriesOutline,
        episodes: state.episodes,
        currentEpisodeIndex: state.currentEpisodeIndex,

        // Single mode data
        storyData: state.storyData,
        storyOutline: state.storyOutline,
        panels: state.panels,
        detailedPanels: state.detailedPanels
      };

      // Save to server
      const success = await saveStoryToServer(storyData);

      if (success) {
        // Update local state
        const existingIndex = state.savedStories.findIndex(s => s.id === storyId);
        if (existingIndex >= 0) {
          state.savedStories[existingIndex] = storyData;
        } else {
          state.savedStories.unshift(storyData);
        }

        state.currentStoryId = storyId;

        if (!autoSave) {
          alert(`‚úÖ ƒê√£ l∆∞u: "${storyName}"`);
        }
        console.log(`üíæ Story saved to server: ${storyName} (${storyId})`);
        render();
        return storyId;
      } else {
        if (!autoSave) {
          alert('‚ùå L·ªói l∆∞u truy·ªán v√†o server!');
        }
        return null;
      }
    }

    // Load a story by ID
    function loadStory(storyId) {
      const story = state.savedStories.find(s => s.id === storyId);
      if (!story) {
        alert('Kh√¥ng t√¨m th·∫•y truy·ªán!');
        return false;
      }

      // Restore settings
      state.genre = story.genre || 'romance';
      state.artStyle = story.artStyle || 'manga';
      state.colorMode = story.colorMode || 'full_color';
      state.lightingStyle = story.lightingStyle || 'natural';
      state.storyMode = story.storyMode || 'single';
      state.storyPrompt = story.storyPrompt || '';
      state.emotionalIntensity = story.emotionalIntensity || 'balanced';
      state.episodesPerSeries = story.episodesPerSeries || 10;
      state.panelsPerEpisode = story.panelsPerEpisode || 15;

      // Restore characters
      state.characters = story.characters || [];

      // Restore story content
      state.seriesOutline = story.seriesOutline;
      state.episodes = story.episodes || [];
      state.currentEpisodeIndex = story.currentEpisodeIndex || 0;

      // Single mode data
      state.storyData = story.storyData;
      state.storyOutline = story.storyOutline;
      state.panels = story.panels || [];
      state.detailedPanels = story.detailedPanels || [];

      // Set current story ID
      state.currentStoryId = storyId;
      state.currentStep = story.panels?.length > 0 || story.episodes?.length > 0 ? 'complete' : 'idle';
      state.showStoryLibrary = false;

      console.log(`üìñ Loaded story: ${story.name}`);
      render();
      return true;
    }

    // Delete a story
    async function deleteStory(storyId) {
      const story = state.savedStories.find(s => s.id === storyId);
      if (!story) return;

      if (!confirm(`X√≥a truy·ªán "${story.name}"? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!`)) {
        return;
      }

      try {
        const response = await fetch(`/api/stories/${storyId}`, {
          method: 'DELETE'
        });
        const data = await response.json();

        if (data.success) {
          state.savedStories = state.savedStories.filter(s => s.id !== storyId);

          // If deleted current story, clear state
          if (state.currentStoryId === storyId) {
            state.currentStoryId = null;
          }

          console.log(`üóëÔ∏è Deleted story from server: ${story.name}`);
          render();
        } else {
          alert('‚ùå L·ªói x√≥a truy·ªán!');
        }
      } catch (e) {
        console.error('‚ùå Error deleting story:', e);
        alert('‚ùå L·ªói x√≥a truy·ªán!');
      }
    }

    // Create new story (clear current)
    function createNewStory() {
      if (state.seriesOutline || state.storyData) {
        if (!confirm('T·∫°o truy·ªán m·ªõi? Nh·ªõ l∆∞u truy·ªán hi·ªán t·∫°i n·∫øu c·∫ßn!')) {
          return;
        }
      }

      // Reset story-related state
      state.currentStoryId = null;
      state.seriesOutline = null;
      state.episodes = [];
      state.currentEpisodeIndex = 0;
      state.storyData = null;
      state.storyOutline = null;
      state.panels = [];
      state.detailedPanels = [];
      state.currentStep = 'idle';
      state.error = '';
      state.storyPrompt = '';
      state.showStoryLibrary = false;

      console.log('üìù Created new story');
      render();
    }

    // Get characters from current or specified story
    function getStoryCharacters(storyId = null) {
      if (storyId) {
        const story = state.savedStories.find(s => s.id === storyId);
        return story?.seriesOutline?.characters || story?.characters || [];
      }
      return state.seriesOutline?.characters || state.characters || [];
    }

    // Initialize - load saved stories on page load
    loadSavedStories();

    const GENRES = [
      { id: 'romance', name: 'T√¨nh c·∫£m', icon: 'üíï', color: '#ff6b9d' },
      { id: 'horror', name: 'Kinh d·ªã', icon: 'üëª', color: '#4a0080' },
      { id: 'comedy', name: 'H√†i h∆∞·ªõc', icon: 'üòÇ', color: '#ffd93d' },
      { id: 'action', name: 'H√†nh ƒë·ªông', icon: '‚öîÔ∏è', color: '#ff4757' },
      { id: 'mystery', name: 'B√≠ ·∫©n', icon: 'üîç', color: '#2f3542' },
      { id: 'fantasy', name: 'K·ª≥ ·∫£o', icon: 'üßô', color: '#a55eea' },
      { id: 'drama', name: 'Drama', icon: 'üé≠', color: '#3742fa' },
      { id: 'slice_of_life', name: 'ƒê·ªùi th∆∞·ªùng', icon: 'üå∏', color: '#ff9ff3' },
    ];

    const ART_STYLES = [
      { id: 'manga', name: 'Manga Nh·∫≠t', preview: 'Manga' },
      { id: 'manhwa', name: 'Manhwa H√†n', preview: 'Manhwa' },
      { id: 'manhua', name: 'Manhua Trung', preview: 'Manhua' },
      { id: 'webtoon', name: 'Webtoon', preview: 'Webtoon' },
      { id: 'chibi', name: 'Chibi', preview: 'Chibi' },
      { id: 'realistic', name: 'Realistic', preview: 'Real' },
    ];

    const STORY_LENGTHS = [
      { id: 'short', name: 'Ng·∫Øn', panels: 5, icon: '‚ö°', desc: '4-6 panels, nhanh g·ªçn' },
      { id: 'medium', name: 'Trung b√¨nh', panels: 10, icon: 'üìñ', desc: '8-12 panels, c√¢n b·∫±ng' },
      { id: 'long', name: 'D√†i', panels: 20, icon: 'üìö', desc: '15-25 panels, epic story' },
      { id: 'epic', name: 'Epic', panels: 40, icon: 'üî•', desc: '30-50 panels, full arc' },
    ];

    const EMOTIONAL_TONES = [
      { id: 'subtle', name: 'Nh·∫π nh√†ng', icon: 'üå∏', desc: 'C·∫£m x√∫c tinh t·∫ø, subtle' },
      { id: 'balanced', name: 'C√¢n b·∫±ng', icon: '‚öñÔ∏è', desc: 'V·ª´a ph·∫£i, t·ª± nhi√™n' },
      { id: 'intense', name: 'M·∫°nh m·∫Ω', icon: 'üî•', desc: 'C·∫£m x√∫c m√£nh li·ªát, dramatic' },
    ];

    // ===========================================
    // COLOR MODES - Ch·∫ø ƒë·ªô m√†u s·∫Øc th·ªëng nh·∫•t xuy√™n su·ªët
    // ===========================================
    const COLOR_MODES = [
      {
        id: 'full_color',
        name: 'Full Color',
        icon: 'üé®',
        desc: 'M√†u s·∫Øc ƒë·∫ßy ƒë·ªß, s·ªëng ƒë·ªông',
        prompt: 'Full color, vibrant colors, rich color palette'
      },
      {
        id: 'limited_color',
        name: 'Limited Palette',
        icon: 'üé≠',
        desc: 'M√†u h·∫°n ch·∫ø, tone nh·∫•t qu√°n',
        prompt: 'Limited color palette, consistent color scheme, 3-4 main colors'
      },
      {
        id: 'black_white',
        name: 'ƒêen Tr·∫Øng',
        icon: '‚¨õ',
        desc: 'Manga c·ªï ƒëi·ªÉn, ƒëen tr·∫Øng',
        prompt: 'Black and white, monochrome, grayscale, classic manga style, no colors'
      },
      {
        id: 'sepia',
        name: 'Sepia/Vintage',
        icon: 'üìú',
        desc: 'Tone n√¢u vintage, ho√†i c·ªï',
        prompt: 'Sepia tones, vintage look, warm brown tints, nostalgic atmosphere'
      }
    ];

    // ===========================================
    // LIGHTING STYLES - √Ånh s√°ng ch·ªß ƒë·∫°o
    // ===========================================
    const LIGHTING_STYLES = [
      { id: 'natural', name: 'T·ª± nhi√™n', icon: '‚òÄÔ∏è', prompt: 'Natural lighting, soft daylight' },
      { id: 'dramatic', name: 'Dramatic', icon: 'üåë', prompt: 'Dramatic lighting, high contrast, strong shadows' },
      { id: 'soft', name: 'M·ªÅm m·∫°i', icon: 'üå§Ô∏è', prompt: 'Soft diffused lighting, gentle shadows' },
      { id: 'neon', name: 'Neon/Cyberpunk', icon: 'üíú', prompt: 'Neon lights, cyberpunk atmosphere, glowing effects' },
      { id: 'golden', name: 'Golden Hour', icon: 'üåÖ', prompt: 'Golden hour lighting, warm sunset tones, romantic atmosphere' }
    ];

    // ===========================================
    // TEXT API HELPER - Call DeepSeek or Gemini based on provider
    // ===========================================
    // options.provider: override provider ('deepseek' or 'gemini')
    async function callTextAPI(systemPrompt, userPrompt, options = {}) {
      // Allow provider override for hybrid mode
      const provider = options.provider || state.textApiProvider;
      const limits = API_LIMITS[provider];

      const temperature = options.temperature || 0.8;
      const maxTokens = Math.min(options.max_tokens || 8000, limits.maxOutputTokens);

      console.log(`\nüîÑ Calling ${limits.name} API...`);
      console.log('  Provider:', provider);
      console.log('  Max tokens:', maxTokens);

      const endpoint = provider === 'gemini' ? '/api/gemini-text' : '/api/deepseek';
      const apiKey = provider === 'gemini' ? state.geminiKey : state.deepseekKey;

      if (!apiKey) {
        throw new Error(`Ch∆∞a c√≥ API key cho ${limits.name}. Vui l√≤ng c√†i ƒë·∫∑t trong ph·∫ßn API Setup.`);
      }

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          apiKey: apiKey,
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: temperature,
          max_tokens: maxTokens
        })
      });

      const data = await response.json();

      if (!response.ok) {
        console.error(`‚ùå ${limits.name} API Error:`, data);
        throw new Error(data.error || `${limits.name} API error`);
      }

      return data;
    }

    // Get current API limits based on selected provider
    function getCurrentLimits() {
      return API_LIMITS[state.textApiProvider];
    }

    // Calculate max SAFE episodes that won't cause truncation
    // Formula: episodes * 600 + 2000 tokens for series outline
    function getMaxSafeEpisodes() {
      const limits = getCurrentLimits();
      const maxSafe = Math.floor((limits.maxOutputTokens - 2000) / 600);
      return Math.min(maxSafe, limits.maxEpisodes);
    }

    // Check if current config might cause truncation
    function getTokenWarning() {
      // In hybrid mode, use Gemini for outline so no truncation issue
      if (state.hybridMode) {
        return { show: false };
      }

      const limits = getCurrentLimits();
      const maxSafe = getMaxSafeEpisodes();

      if (state.episodesPerSeries > maxSafe) {
        const tokensNeeded = state.episodesPerSeries * 600 + 2000;
        return {
          show: true,
          severity: state.episodesPerSeries > maxSafe * 1.5 ? 'error' : 'warning',
          message: `${state.episodesPerSeries} chap c·∫ßn ~${tokensNeeded.toLocaleString()} tokens, ${limits.name} ch·ªâ h·ªó tr·ª£ ${limits.maxOutputTokens.toLocaleString()} tokens!`,
          suggestion: limits.name === 'DeepSeek'
            ? `ƒê·ªÅ xu·∫•t: Chuy·ªÉn sang Gemini 3 Pro (65k tokens) ho·∫∑c gi·∫£m c√≤n ‚â§${maxSafe} chap`
            : `ƒê·ªÅ xu·∫•t: Gi·∫£m c√≤n ‚â§${maxSafe} chap ƒë·ªÉ tr√°nh b·ªã c·∫Øt`
        };
      }
      return { show: false };
    }

    // Get effective limits (uses Gemini limits when hybrid mode is enabled for outline)
    function getEffectiveLimits() {
      if (state.hybridMode) {
        return {
          ...API_LIMITS.gemini,
          name: 'Hybrid (Gemini + DeepSeek)',
          description: 'Gemini t·∫°o outline, DeepSeek t·∫°o panel details'
        };
      }
      return getCurrentLimits();
    }

    // Switch text API provider
    function switchTextProvider(provider) {
      if (provider === 'deepseek' || provider === 'gemini') {
        state.textApiProvider = provider;
        localStorage.setItem('textApiProvider', provider);

        // Adjust episodes limit based on provider
        const limits = API_LIMITS[provider];
        if (state.episodesPerSeries > limits.maxEpisodes) {
          state.episodesPerSeries = limits.maxEpisodes;
        }

        console.log(`‚úÖ Switched to ${limits.name}`);
        console.log(`   Max episodes: ${limits.maxEpisodes}`);
        console.log(`   Max output tokens: ${limits.maxOutputTokens}`);

        render();
      }
    }

    // API Functions
    async function generateStory() {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const selectedTone = EMOTIONAL_TONES.find(t => t.id === state.emotionalIntensity);

      const charactersPrompt = state.characters.length > 0
        ? `\n\nNH√ÇN V·∫¨T CH√çNH (gi·ªØ nh·∫•t qu√°n qua c√°c panel):\n${state.characters.map(c =>
            `- ${c.name}: ${c.description}`
          ).join('\n')}`
        : '';

      const emotionalGuidance = {
        subtle: 'C·∫£m x√∫c tinh t·∫ø, ng·∫ßm hi·ªÉu, kh√¥ng qu√° dramatic. Di·ªÖn bi·∫øn t·ª´ t·ª´, t·ª± nhi√™n.',
        balanced: 'C·∫£m x√∫c r√µ r√†ng nh∆∞ng kh√¥ng over-the-top. C√¢n b·∫±ng gi·ªØa subtle v√† expressive.',
        intense: 'C·∫£m x√∫c m√£nh li·ªát, dramatic, s√¢u s·∫Øc. Di·ªÖn bi·∫øn nhanh v·ªõi high stakes v√† strong reactions.'
      };

      const systemPrompt = `B·∫°n l√† m·ªôt bi√™n k·ªãch truy·ªán tranh chuy√™n nghi·ªáp, chuy√™n t·∫°o c√¢u chuy·ªán ho√†n ch·ªânh, cu·ªën h√∫t v·ªõi c·∫•u tr√∫c r√µ r√†ng.

NGUY√äN T·∫ÆC K·ªäCH B·∫¢N:
1. **C·∫•u tr√∫c 3 h·ªìi**: Setup ‚Üí Conflict/Development ‚Üí Resolution
2. **Character Development**: Nh√¢n v·∫≠t ph·∫£i c√≥ c·∫£m x√∫c, ƒë·ªông l·ª±c, v√† s·ª± thay ƒë·ªïi T·ª∞ NHI√äN
3. **Visual Storytelling**: M·ªói panel l√† m·ªôt "shot" ƒëi·ªán ·∫£nh, c√≥ g√≥c m√°y v√† composition r√µ r√†ng
4. **Dialogue**: T·ª± nhi√™n, c√≥ t√≠nh c√°ch, tr√°nh exposition th√¥
5. **Pacing T·ª∞ NHI√äN**: Xen k·∫Ω moments cƒÉng th·∫≥ng v·ªõi nh·∫π nh√†ng, climax ·ªü 70-80%
6. **Emotional Journey**: C·∫£m x√∫c ph√°t tri·ªÉn ORGANIC t·ª´ h√†nh tr√¨nh nh√¢n v·∫≠t

üé≠ THU H√öT ƒê·ªòC GI·∫¢ (T·ª∞ NHI√äN, KH√îNG L·∫†M D·ª§NG):
- Opening th√∫ v·ªã nh∆∞ng kh√¥ng g∆∞·ª£ng √©p shock
- Twist/revelation (n·∫øu c√≥) ph·∫£i c√≥ foreshadowing h·ª£p l√Ω, logic v·ªõi c√¢u chuy·ªán
- C√¢u h·ªèi/b√≠ m·∫≠t ch·ªâ khi PH√ô H·ª¢P v·ªõi th·ªÉ lo·∫°i v√† c·ªët truy·ªán
- C·∫£m x√∫c ch√¢n th·ª±c, kh√¥ng melodrama
- Ending c√≥ impact nh∆∞ng th·ªèa m√£n, h·ª£p logic

QUY T·∫ÆC K·ª∏ THU·∫¨T:
1. N·∫øu user kh√¥ng cung c·∫•p nh√¢n v·∫≠t, T·ª∞ ƒê·ªòNG T·∫†O nh√¢n v·∫≠t ph√π h·ª£p v·ªõi th·ªÉ lo·∫°i:
   - Romance/Drama/Slice of Life: 2-3 nh√¢n v·∫≠t ch√≠nh
   - Action/Fantasy/Mystery: 4-6 nh√¢n v·∫≠t (bao g·ªìm c·∫£ main & supporting characters)
   - Horror: 3-4 nh√¢n v·∫≠t
2. PH√ÇN LO·∫†I NH√ÇN V·∫¨T:
   - **Main Characters** (role: protagonist/antagonist): M√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT (age, gender, hairstyle color/length/style, eye color, facial features, body type, clothing details, accessories)
   - **Supporting Characters** (role: supporting): M√¥ t·∫£ chi ti·∫øt nh∆∞ng ng·∫Øn g·ªçn h∆°n
   - **Background/Crowd**: KH√îNG c·∫ßn li·ªát k√™ t·ª´ng ng∆∞·ªùi, ch·ªâ m√¥ t·∫£ chung trong scene_description (VD: "10 chi·∫øn binh m·∫∑c √°o ƒëen ƒë·ª©ng sau", "ƒë√°m ƒë√¥ng la h√©t")
3. M·ªói panel c√≥: scene description (bao g·ªìm crowd n·∫øu c√≥), character positions, facial expressions, dialogue (ng·∫Øn g·ªçn), camera angle, mood/lighting
4. Dialogue vi·∫øt theo format: "Character: text" ƒë·ªÉ d·ªÖ render speech bubbles
5. Image prompts ph·∫£i bao g·ªìm: main character descriptions, supporting character descriptions (n·∫øu xu·∫•t hi·ªán), crowd description (n·∫øu c√≥), action/pose, emotion, background, lighting, camera angle
6. Format JSON thu·∫ßn, KH√îNG markdown backticks

QUAN TR·ªåNG - CHARACTER CONSISTENCY:
- Main characters: M√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT v√† NH·∫§T QU√ÅN trong visual_description
- Supporting characters: M√¥ t·∫£ ƒë·ªß chi ti·∫øt ƒë·ªÉ nh·∫≠n di·ªán
- Background/Crowd: M√¥ t·∫£ chung chung l√† ƒë·ªß (VD: "nh√≥m chi·∫øn binh", "ƒë√°m ƒë√¥ng", kh√¥ng c·∫ßn t√™n ri√™ng)
- Trong image_prompts, LU√îN bao g·ªìm FULL description c·ªßa main & supporting characters xu·∫•t hi·ªán trong panel ƒë√≥
- VD: "Ch√†ng trai 24 tu·ªïi t√≥c ƒëen d√†i...[full description]... ƒëang ƒë√°nh nhau. Ph√≠a sau c√≥ 8 chi·∫øn binh m·∫∑c √°o tr·∫Øng c·∫ßm ki·∫øm."
- Crowd/background characters kh√¥ng c·∫ßn l·∫∑p l·∫°i chi ti·∫øt qua c√°c panel, ch·ªâ c·∫ßn m√¥ t·∫£ vai tr√≤

ART STYLE GUIDE (TH·ªêNG NH·∫§T CHO TO√ÄN B·ªò TRUY·ªÜN):
- Ki·ªÉu v·∫Ω: ${selectedStyle.name}
- M√†u s·∫Øc: ${selectedColorMode.name} - ${selectedColorMode.prompt}
- √Ånh s√°ng ch·ªß ƒë·∫°o: ${selectedLighting.name} - ${selectedLighting.prompt}
‚ö†Ô∏è B·∫ÆT BU·ªòC: Gi·ªØ NH·∫§T QU√ÅN style n√†y cho T·∫§T C·∫¢ panels!

M√î T·∫¢ NH√ÇN V·∫¨T THEO CONTEXT:
- M·ªói panel c·∫ßn m√¥ t·∫£ chi ti·∫øt: t√≥c (m√†u, ki·ªÉu, ƒë·ªô d√†i), m·∫Øt (m√†u, ki·ªÉu), khu√¥n m·∫∑t
- TRANG PH·ª§C: Ph·∫£i PH√ô H·ª¢P V·ªöI CONTEXT c·ªßa scene!
  + Scene b√¨nh th∆∞·ªùng: trang ph·ª•c m·∫∑c ƒë·ªãnh
  + ƒê√°m c∆∞·ªõi/ti·ªác: vest/v√°y d·∫° h·ªôi
  + Chi·∫øn ƒë·∫•u: √°o gi√°p/trang ph·ª•c chi·∫øn
  + Ng·ªß/nh√†: ƒë·ªì ng·ªß/ƒë·ªì ·ªü nh√†
- ƒê·∫∑c ƒëi·ªÉm nh·∫≠n d·∫°ng (s·∫πo, n·ªët ru·ªìi...): Lu√¥n gi·ªØ nh·∫•t qu√°n`;

      // Determine character count based on genre
      const characterGuidance = {
        romance: '2-3 nh√¢n v·∫≠t ch√≠nh v·ªõi m√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT',
        slice_of_life: '2-3 nh√¢n v·∫≠t ch√≠nh v·ªõi m√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT',
        drama: '2-3 nh√¢n v·∫≠t ch√≠nh v·ªõi m√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT',
        horror: '3-4 nh√¢n v·∫≠t (main + supporting) v·ªõi m√¥ t·∫£ C·ª∞C K·ª≤ CHI TI·∫æT',
        action: '4-6 nh√¢n v·∫≠t (bao g·ªìm main characters v√† supporting characters). V√ç D·ª§: 2 nh√¢n v·∫≠t ch√≠nh t·ª´ m√¥n ph√°i ch√≠nh, 2 nh√¢n v·∫≠t ch√≠nh t·ª´ m√¥n ph√°i t√†, 2-3 nh√¢n v·∫≠t ph·ª• (s∆∞ ph·ª•, ƒë·ªì ƒë·ªá, v.v.). TH√äM crowd/background characters khi c·∫ßn (chi·∫øn binh, qu·∫ßn ch√∫ng) - ch·ªâ m√¥ t·∫£ chung trong scene kh√¥ng c·∫ßn t√™n ri√™ng',
        fantasy: '4-6 nh√¢n v·∫≠t (main + supporting + creatures/beings n·∫øu c·∫ßn)',
        mystery: '3-5 nh√¢n v·∫≠t (detective, suspects, supporting)',
        comedy: '2-4 nh√¢n v·∫≠t t√πy theo comedy type'
      };

      const charGuide = characterGuidance[state.genre] || '2-3 nh√¢n v·∫≠t ch√≠nh';

      const userPrompt = `T·∫°o truy·ªán tranh ${state.panelCount} panel theo th·ªÉ lo·∫°i: ${selectedGenre.name} ${selectedGenre.icon}
${charactersPrompt || `\n**L∆ØU √ù**: User ch∆∞a ƒë·ªãnh nghƒ©a nh√¢n v·∫≠t. H√ÉY T·ª∞ ƒê·ªòNG T·∫†O ${charGuide}. M·ªói nh√¢n v·∫≠t c·∫ßn visual description C·ª∞C K·ª≤ CHI TI·∫æT (age, gender, hairstyle v·ªõi color/length/style, eye color, facial features, body type, clothing details, accessories).`}

√ù t∆∞·ªüng: ${state.storyPrompt || 'T·ª± do s√°ng t·∫°o m·ªôt c√¢u chuy·ªán h·∫•p d·∫´n, ƒë·∫ßy c·∫£m x√∫c v·ªõi twist b·∫•t ng·ªù'}

**EMOTIONAL TONE**: ${selectedTone.name} - ${emotionalGuidance[state.emotionalIntensity]}

**Y√äU C·∫¶U QUAN TR·ªåNG**:
- T·∫°o c√¢u chuy·ªán HO√ÄN CH·ªàNH v·ªõi beginning/middle/end r√µ r√†ng
- Nh√¢n v·∫≠t ph·∫£i c√≥ CHARACTER ARC (s·ª± thay ƒë·ªïi/nh·∫≠n ra ƒëi·ªÅu g√¨ ƒë√≥)
- Dialogue t·ª± nhi√™n, c√≥ c·∫£m x√∫c, format: "T√™n: L·ªùi tho·∫°i"
- M·ªói panel ph·∫£i ƒë·∫©y story forward, kh√¥ng l·∫∑p l·∫°i
- Climax ·ªü panel th·ª© ${Math.floor(state.panelCount * 0.7)}-${Math.floor(state.panelCount * 0.8)}
- Ending ph·∫£i c√≥ emotional impact ho·∫∑c twist
${state.genre === 'action' ? `
- V·ªöI TH·ªÇ LO·∫†I ACTION:
  * T·∫°o 4-6 nh√¢n v·∫≠t c√≥ T√äN (main + supporting) trong characters array
  * TH√äM crowd/background ƒë·ªÉ t·∫°o s·ª± h√πng tr√°ng: "30 chi·∫øn binh m√¥n ph√°i ch√≠nh", "ƒë√°m ƒë√¥ng m√¥n ph√°i t√†", "c√°c ƒë·ªì ƒë·ªá xung quanh"
  * Crowd KH√îNG c·∫ßn t√™n ri√™ng, ch·ªâ m√¥ t·∫£ chung trong scene_description v√† image_prompts
  * V√ç D·ª§ scene_description: "ƒê·ªânh n√∫i tuy·∫øt, tuy·∫øt r∆°i d√†y. L√¢m Phong ƒë·ª©ng gi·ªØa, ph√≠a sau c√≥ 25 chi·∫øn binh m√¥n ph√°i Thi√™n Ki·∫øm m·∫∑c √°o tr·∫Øng c·∫ßm ki·∫øm. ƒê·ªëi di·ªán l√† Huy·∫øt ·∫¢nh v·ªõi 30 chi·∫øn binh m√¥n ph√°i H·∫Øc Ma m·∫∑c √°o ƒëen."
  * V√ç D·ª§ image_prompt: "Ch√†ng trai 24 tu·ªïi t√≥c ƒëen...[full description]... ƒë·ª©ng gi·ªØa. C√¥ g√°i 22 tu·ªïi t√≥c ƒë·ªè...[full description]... ƒë·ªëi di·ªán. Behind them: 25 white-robed warriors with swords vs 30 black-robed warriors. Setting: snowy mountain peak..."` : ''}

Tr·∫£ v·ªÅ JSON v·ªõi format sau (KH√îNG th√™m markdown hay backticks, ch·ªâ JSON thu·∫ßn):
{
  "title": "Ti√™u ƒë·ªÅ h·∫•p d·∫´n, s√∫c t√≠ch",
  "synopsis": "T√≥m t·∫Øt 2-3 c√¢u v·ªõi hook",
  "theme": "Ch·ªß ƒë·ªÅ/th√¥ng ƒëi·ªáp ch√≠nh c·ªßa story",
  "characters": [
    {
      "name": "T√™n nh√¢n v·∫≠t ch√≠nh ho·∫∑c ph·ª• (VD: L√¢m Phong, Huy·∫øt ·∫¢nh, S∆∞ ph·ª• V√¢n Ti√™u)",
      "role": "protagonist/antagonist/supporting",
      "personality": "T√≠nh c√°ch ng·∫Øn g·ªçn",
      "visual_description": "M√¥ t·∫£ SI√äU CHI TI·∫æT cho main (protagonist/antagonist), chi ti·∫øt v·ª´a ph·∫£i cho supporting: [Age] tu·ªïi [gender], t√≥c [color] [length] [style], m·∫Øt [color] [shape], [height], [body type], m·∫∑c [clothing details v·ªõi m√†u s·∫Øc v√† style c·ª• th·ªÉ], [accessories]. VD: C√¥ g√°i 22 tu·ªïi, t√≥c v√†ng d√†i qua vai u·ªën l·ªçn nh·∫π, m·∫Øt xanh d∆∞∆°ng h√¨nh h·∫°nh nh√¢n, cao 1m68, d√°ng ng∆∞·ªùi thon g·ªçn, m·∫∑c √°o s∆° mi tr·∫Øng c·ªï V v·ªõi cardigan be, qu·∫ßn jeans skinny xanh ƒë·∫≠m, ƒëeo v√≤ng c·ªï b·∫°c h√¨nh tr√°i tim"
    }
  ],
  "crowd_note": "N·∫øu c√≥ crowd/background characters (chi·∫øn binh, qu·∫ßn ch√∫ng, ƒë·ªì ƒë·ªá), KH√îNG c·∫ßn th√™m v√†o characters array. Ch·ªâ m√¥ t·∫£ trong scene_description v√† image_prompts. VD: '20 chi·∫øn binh m√¥n ph√°i ch√≠nh m·∫∑c √°o tr·∫Øng ƒë·ª©ng sau', 'ƒë√°m ƒë√¥ng m√¥n ph√°i t√† m·∫∑c √°o ƒëen xung quanh'",
  "panels": [
    {
      "panel_number": 1,
      "scene_description": "M√¥ t·∫£ to√†n c·∫£nh: ƒë·ªãa ƒëi·ªÉm, th·ªùi gian, kh√¥ng kh√≠. B·∫ÆT BU·ªòC bao g·ªìm crowd/background n·∫øu c√≥ (VD: 'ƒê·ªânh n√∫i tuy·∫øt, 30 chi·∫øn binh m√¥n ph√°i ch√≠nh m·∫∑c √°o tr·∫Øng ƒë·ª©ng sau nh√¢n v·∫≠t ch√≠nh, 25 chi·∫øn binh m√¥n ph√°i t√† m·∫∑c √°o ƒëen ·ªü ph√≠a ƒë·ªëi di·ªán')",
      "character_positions": "V·ªã tr√≠ v√† h√†nh ƒë·ªông c·ªßa T·ª™NG nh√¢n v·∫≠t CH√çNH & PH·ª§ (characters trong array). Crowd ch·ªâ c·∫ßn m√¥ t·∫£ v·ªã tr√≠ chung",
      "character_expressions": "Bi·ªÉu c·∫£m khu√¥n m·∫∑t C·ª§ TH·ªÇ c·ªßa nh√¢n v·∫≠t ch√≠nh & ph·ª• (VD: 'Minh cau m√†y lo l·∫Øng, Hoa m·ªâm c∆∞·ªùi g∆∞·ª£ng g·∫°o')",
      "dialogue": "ƒê·ªëi tho·∫°i theo format 'T√™n: L·ªùi n√≥i' (ng·∫Øn g·ªçn, t·ª± nhi√™n)",
      "narration": "Caption/narration box n·∫øu c·∫ßn context",
      "camera_angle": "close-up/medium shot/wide shot/dutch angle/low angle/high angle/over-the-shoulder",
      "mood": "Kh√¥ng kh√≠ c·∫£m x√∫c (VD: 'CƒÉng th·∫≥ng, s·ª£ h√£i', '·∫§m √°p, l√£ng m·∫°n')",
      "lighting": "√Ånh s√°ng (VD: 'Ho√†ng h√¥n v√†ng', 'ƒê√™m t·ªëi v·ªõi ƒë√®n neon', 'S√°ng t·ª± nhi√™n')"
    }
  ],
  "image_prompts": [
    "COMIC PANEL ART, ${selectedStyle.name} style, ${selectedColorMode.prompt}, ${selectedLighting.prompt}. [FULL main character visual descriptions - include ALL details: age, hair color/length/style, eyes, face, clothing THEO CONTEXT, accessories] + [Supporting character descriptions n·∫øu xu·∫•t hi·ªán] + [Crowd/background n·∫øu c√≥]. [Action/pose], [facial expression], [emotion]. Setting: [background details]. [Camera angle]. High quality manga/comic art, speech bubbles visible (Vietnamese text ONLY), TikTok vertical format 9:16. IMPORTANT: M√¥ t·∫£ chi ti·∫øt t√≥c, m·∫Øt, khu√¥n m·∫∑t, trang ph·ª•c PH√ô H·ª¢P CONTEXT c·ªßa t·ª´ng panel."
  ]
}`;

      // Calculate required tokens based on panel count and genre
      // Action/Fantasy genres need more tokens due to more characters
      const limits = getCurrentLimits();
      const genreMultiplier = ['action', 'fantasy'].includes(state.genre) ? 700 : 600;
      const estimatedTokens = Math.min(limits.maxOutputTokens, Math.max(6000, state.panelCount * genreMultiplier + 1500));

      // Calculate max safe panels for current genre
      const maxSafePanels = Math.floor((limits.maxOutputTokens - 1500) / genreMultiplier);

      console.log('üìä Using API:', limits.name);
      console.log('üìä Estimated tokens needed:', estimatedTokens, '(genre:', state.genre, ')');
      console.log('üìä Max tokens allowed:', limits.maxOutputTokens);
      console.log('üìä Max safe panels for', state.genre, 'genre:', maxSafePanels);

      if (state.panelCount * genreMultiplier + 1500 > limits.maxOutputTokens) {
        console.warn(`‚ö†Ô∏è WARNING: ${state.panelCount} panels may exceed token limit!`);
        console.warn(`Recommended: Use max ${maxSafePanels} panels for ${state.genre} genre`);
      }

      const data = await callTextAPI(systemPrompt, userPrompt, {
        temperature: 0.8,
        max_tokens: estimatedTokens
      });

      let content = data.choices[0].message.content;
      const tokensUsed = data.usage?.total_tokens || 0;
      const finishReason = data.choices[0].finish_reason;

      console.log('üì¶ Raw DeepSeek Response (length:', content.length, ')');
      console.log('üî¢ Tokens used:', tokensUsed, '| Finish reason:', finishReason);
      console.log('First 500 chars:', content.substring(0, 500));

      // Check if response was truncated
      if (finishReason === 'length') {
        console.warn('‚ö†Ô∏è WARNING: Response was truncated due to max_tokens limit!');
        console.warn('Consider increasing max_tokens or reducing panel count');
      }

      // Clean up markdown code blocks
      content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

      // Additional cleanup for common JSON issues
      // Remove any BOM or invisible characters at the start
      content = content.replace(/^\uFEFF/, '');

      console.log('üßπ Cleaned content (length:', content.length, ')');
      console.log('First 500 chars after cleanup:', content.substring(0, 500));

      // Try to parse JSON
      try {
        const parsed = JSON.parse(content);
        console.log('‚úÖ Successfully parsed JSON:', parsed);
        return parsed;
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error:', parseError);
        console.error('üìç Error message:', parseError.message);

        // Try to find the problematic area using position
        const posMatch = parseError.message.match(/position (\d+)/);
        if (posMatch) {
          const pos = parseInt(posMatch[1]);
          const start = Math.max(0, pos - 150);
          const end = Math.min(content.length, pos + 150);
          console.error('üîç Context around error position', pos, ':');
          console.error(content.substring(start, end));
          console.error(' '.repeat(Math.min(150, pos - start)) + '^--- ERROR HERE');
        }

        // Try to find line and column
        const lineMatch = parseError.message.match(/line (\d+) column (\d+)/);
        if (lineMatch) {
          const line = parseInt(lineMatch[1]);
          const col = parseInt(lineMatch[2]);
          const lines = content.split('\n');
          console.error(`üîç Error at line ${line}, column ${col}:`);
          if (lines[line - 1]) {
            console.error('Line content:', lines[line - 1]);
            console.error(' '.repeat(col - 1) + '^--- ERROR HERE');

            // Show surrounding lines
            const startLine = Math.max(0, line - 3);
            const endLine = Math.min(lines.length, line + 2);
            console.error('\nüìÑ Context (lines', startLine + 1, '-', endLine + 1, '):');
            for (let i = startLine; i < endLine; i++) {
              const marker = i === line - 1 ? '>>> ' : '    ';
              console.error(marker + (i + 1) + ':', lines[i]);
            }
          }
        }

        console.error('\nüìÑ Full content (for manual inspection):');
        console.error(content);

        // Check if error was due to truncation
        let errorMsg = `JSON parsing failed: ${parseError.message}`;
        if (finishReason === 'length') {
          errorMsg = `‚ö†Ô∏è Response b·ªã c·∫Øt c·ª•t do h·∫øt token!\n\n` +
                     `ƒê√£ d√πng ${tokensUsed} tokens, c·∫ßn th√™m n·ªØa.\n` +
                     `Gi·∫£i ph√°p:\n` +
                     `1. Gi·∫£m s·ªë panel xu·ªëng (hi·ªán t·∫°i: ${state.panelCount})\n` +
                     `2. Ho·∫∑c ƒë·ª£i AI t·ª± ƒë·ªông tƒÉng max_tokens\n\n` +
                     `Chi ti·∫øt l·ªói: ${parseError.message}`;
        }

        errorMsg += '\n\nM·ªü Browser Console (F12) ƒë·ªÉ xem chi ti·∫øt.';
        throw new Error(errorMsg);
      }
    }

    // TWO-STAGE GENERATION FUNCTIONS

    // Stage 1: Generate story outline with characters and panel summaries (with auto-retry)
    async function generateStoryOutline() {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const selectedTone = EMOTIONAL_TONES.find(t => t.id === state.emotionalIntensity);

      const emotionalGuidance = {
        subtle: 'C·∫£m x√∫c tinh t·∫ø, nh·∫π nh√†ng, kh√¥ng qu√° k·ªãch t√≠nh',
        balanced: 'C√¢n b·∫±ng gi·ªØa c·∫£m x√∫c v√† h√†nh ƒë·ªông, t·ª± nhi√™n',
        intense: 'C·∫£m x√∫c m√£nh li·ªát, k·ªãch t√≠nh cao, dramatic'
      };

      // Build characters prompt
      let charactersPrompt = '';
      if (state.characters.length > 0) {
        charactersPrompt = '\n**NH√ÇN V·∫¨T (user ƒë·ªãnh nghƒ©a)**:\n';
        state.characters.forEach((char, i) => {
          charactersPrompt += `${i + 1}. ${char.name}: ${char.description}\n`;
        });
      }

      const systemPrompt = `B·∫°n l√† chuy√™n gia vi·∫øt k·ªãch b·∫£n truy·ªán tranh/manhwa/manga chuy√™n nghi·ªáp.

NHI·ªÜM V·ª§: T·∫°o STORY OUTLINE (ph√°c th·∫£o truy·ªán) g·ªìm:
1. Characters: Danh s√°ch nh√¢n v·∫≠t v·ªõi m√¥ t·∫£ C∆† B·∫¢N v·ªÅ ngo·∫°i h√¨nh
2. Panel Summaries: T√≥m t·∫Øt ng·∫Øn g·ªçn cho T·ª™NG panel

‚ö†Ô∏è CRITICAL - BE EXTREMELY CONCISE:
- Visual descriptions: 40-50 words MAX per character
- Panel summaries: 1 sentence ONLY (10-15 words MAX)
- NO redundant words, NO examples in output

üé≠ K·ª∏ THU·∫¨T THU H√öT ƒê·ªòC GI·∫¢ (T·ª∞ NHI√äN, H·ª¢P L√ù):

‚ö†Ô∏è QUAN TR·ªåNG: √Åp d·ª•ng ORGANIC, ph·ª•c v·ª• c·ªët truy·ªán, KH√îNG g∆∞·ª£ng √©p!

1. **OPENING THU H√öT**: Panel ƒë·∫ßu t·∫°o b·ªëi c·∫£nh/t√¨nh hu·ªëng th√∫ v·ªã m·ªôt c√°ch T·ª∞ NHI√äN
2. **C√ÇU H·ªéI/T√í M√í**: N·∫øu ph√π h·ª£p v·ªõi th·ªÉ lo·∫°i, c√≥ th·ªÉ c√†i c·∫Øm 1 c√¢u h·ªèi/b√≠ m·∫≠t
3. **PH√ÅT TRI·ªÇN T·ª∞ NHI√äN**:
   - Tension tƒÉng d·∫ßn theo logic c√¢u chuy·ªán
   - Climax ·ªü panel ${Math.floor(state.panelCount * 0.7)}-${Math.floor(state.panelCount * 0.8)}
   - Twist/revelation (n·∫øu c√≥) ph·∫£i c√≥ foreshadowing h·ª£p l√Ω
4. **C·∫¢M X√öC CH√ÇN TH·ª∞C**: ƒê·ªÉ nh√¢n v·∫≠t ph√°t tri·ªÉn t·ª± nhi√™n, c·∫£m x√∫c c√≥ nguy√™n nh√¢n r√µ r√†ng
5. **ENDING TH·ªéA M√ÉN**: K·∫øt th√∫c c√≥ impact nh∆∞ng h·ª£p logic v·ªõi to√†n b·ªô c√¢u chuy·ªán

L∆ØU √ù V·ªÄ TRANG PH·ª§C:
- Trong outline ch·ªâ m√¥ t·∫£ trang ph·ª•c M·∫∂C ƒê·ªäNH
- Trang ph·ª•c theo context s·∫Ω ƒë∆∞·ª£c th√™m ·ªü stage 2

ART STYLE GUIDE:
- Ki·ªÉu v·∫Ω: ${selectedStyle.name}
- M√†u s·∫Øc: ${selectedColorMode.name}
- √Ånh s√°ng: ${selectedLighting.name}

FORMAT OUTPUT: JSON thu·∫ßn, KH√îNG markdown backticks`;

      const characterGuidance = {
        romance: '2-3 nh√¢n v·∫≠t ch√≠nh',
        slice_of_life: '2-3 nh√¢n v·∫≠t ch√≠nh',
        drama: '2-3 nh√¢n v·∫≠t ch√≠nh',
        horror: '3-4 nh√¢n v·∫≠t',
        action: '4-6 nh√¢n v·∫≠t (main + supporting, plus crowd/background m√¥ t·∫£ chung)',
        fantasy: '4-6 nh√¢n v·∫≠t (main + supporting)',
        mystery: '3-5 nh√¢n v·∫≠t',
        comedy: '2-4 nh√¢n v·∫≠t'
      };

      const charGuide = characterGuidance[state.genre] || '2-3 nh√¢n v·∫≠t ch√≠nh';

      const userPrompt = `T·∫°o STORY OUTLINE cho truy·ªán ${state.panelCount} panel, th·ªÉ lo·∫°i: ${selectedGenre.name} ${selectedGenre.icon}
${charactersPrompt || `\n**L∆ØU √ù**: User ch∆∞a ƒë·ªãnh nghƒ©a nh√¢n v·∫≠t. H√ÉY T·ª∞ ƒê·ªòNG T·∫†O ${charGuide}. M·ªói nh√¢n v·∫≠t c·∫ßn visual description CHI TI·∫æT (age, gender, hair color/style, eyes, clothing, 1-2 accessories).`}

√ù t∆∞·ªüng: ${state.storyPrompt || 'T·ª± do s√°ng t·∫°o m·ªôt c√¢u chuy·ªán h·∫•p d·∫´n, ƒë·∫ßy c·∫£m x√∫c v·ªõi twist b·∫•t ng·ªù'}

**EMOTIONAL TONE**: ${selectedTone.name} - ${emotionalGuidance[state.emotionalIntensity]}

**Y√äU C·∫¶U**:
- Story arc: Beginning ‚Üí Development ‚Üí Climax ‚Üí Resolution
- Climax ·ªü panel ${Math.floor(state.panelCount * 0.7)}-${Math.floor(state.panelCount * 0.8)}
- Panel summary: 1 c√¢u ng·∫Øn g·ªçn m√¥ t·∫£ scene & action
- Characters: Chi ti·∫øt ngo·∫°i h√¨nh (40-50 words m·ªói nh√¢n v·∫≠t)
${state.genre === 'action' ? '- Action: 4-6 nh√¢n v·∫≠t c√≥ T√äN, crowd m√¥ t·∫£ chung' : ''}

Tr·∫£ v·ªÅ JSON:
{
  "title": "Ti√™u ƒë·ªÅ H·∫§P D·∫™N, g·ª£i t√≤ m√≤",
  "synopsis": "T√≥m t·∫Øt 2 c√¢u v·ªõi HOOK thu h√∫t",
  "theme": "Ch·ªß ƒë·ªÅ ch√≠nh",
  "story_mystery": "B√≠ m·∫≠t/c√¢u h·ªèi ch√≠nh c·ªßa truy·ªán (s·∫Ω reveal ·ªü cu·ªëi)",
  "twist_moment": "M√¥ t·∫£ twist/shocking moment ch√≠nh c·ªßa truy·ªán",
  "characters": [
    {
      "name": "T√™n",
      "role": "protagonist/antagonist/supporting",
      "personality": "T√≠nh c√°ch (3-5 t·ª´)",
      "visual_description": "Age, gender, hair, eyes, body type, clothing, accessories",
      "secret": "B√≠ m·∫≠t c·ªßa nh√¢n v·∫≠t (n·∫øu c√≥)"
    }
  ],
  "panel_summaries": [
    {
      "panel_number": 1,
      "summary": "1 c√¢u ng·∫Øn: location + character + action",
      "emotional_beat": "1-2 t·ª´ c·∫£m x√∫c",
      "story_note": "Setup/Conflict/Climax/Resolution",
      "hook_element": "Y·∫øu t·ªë g√¢y t√≤ m√≤/h·∫•p d·∫´n c·ªßa panel n√†y (n·∫øu c√≥)"
    }
  ]
}`;

      console.log('üìã Generating story outline...');
      console.log('Panel count:', state.panelCount);

      // Auto-retry logic with increasing tokens
      const limits = getCurrentLimits();
      let outlineTokens = Math.min(limits.maxOutputTokens, Math.max(3000, state.panelCount * 120 + 1500));
      let attempts = 0;
      const MAX_ATTEMPTS = 2;

      while (attempts < MAX_ATTEMPTS) {
        attempts++;
        console.log(`\nüîÑ Attempt ${attempts}/${MAX_ATTEMPTS}`);
        console.log('üìä Using API:', limits.name);
        console.log('üìä Outline tokens allocated:', outlineTokens);

        const data = await callTextAPI(systemPrompt, userPrompt, {
          temperature: 0.8,
          max_tokens: outlineTokens
        });

        let content = data.choices[0].message.content;
        const tokensUsed = data.usage?.total_tokens || 0;
        const finishReason = data.choices[0].finish_reason;

        console.log('‚úÖ Story outline generated');
        console.log('Outline length:', content.length);
        console.log('üî¢ Tokens used:', tokensUsed, '/', outlineTokens);
        console.log('‚öôÔ∏è Finish reason:', finishReason);

        // Check if truncated
        if (finishReason === 'length') {
          console.warn(`‚ö†Ô∏è Attempt ${attempts}: Outline was truncated!`);

          if (attempts < MAX_ATTEMPTS) {
            // Retry with 30% more tokens
            const newTokens = Math.min(limits.maxOutputTokens, Math.floor(outlineTokens * 1.3));
            console.log(`üîÑ Retrying with ${newTokens} tokens (${newTokens - outlineTokens} more)...`);
            outlineTokens = newTokens;
            await new Promise(r => setTimeout(r, 1000)); // Wait 1s before retry
            continue; // Retry loop
          } else {
            // Max attempts reached
            console.error('‚ùå Failed after', MAX_ATTEMPTS, 'attempts');
            throw new Error(`‚ö†Ô∏è Story outline qu√° d√†i sau ${MAX_ATTEMPTS} l·∫ßn th·ª≠!\n\nV·ªõi ${state.panelCount} panels c·∫ßn ${tokensUsed}+ tokens nh∆∞ng ch·ªâ c√≥ ${outlineTokens} tokens.\n\nGi·∫£i ph√°p:\n1. Gi·∫£m s·ªë panels xu·ªëng (th·ª≠ ${Math.floor(state.panelCount * 0.7)} panels)\n2. Ho·∫∑c ƒë∆°n gi·∫£n h√≥a √Ω t∆∞·ªüng truy·ªán\n3. Gi·∫£m s·ªë nh√¢n v·∫≠t`);
          }
        }

        // Success! Parse JSON
        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        content = content.replace(/^\uFEFF/, '');

        try {
          const parsed = JSON.parse(content);
          console.log('üìã Outline:', parsed.title);
          console.log('üë• Characters:', parsed.characters?.length || 0);
          console.log('üìÑ Panel summaries:', parsed.panel_summaries?.length || 0);
          console.log('‚úÖ Success on attempt', attempts);
          return parsed;
        } catch (parseError) {
          console.error('‚ùå JSON Parse Error:', parseError);
          console.error('üìÑ Raw content length:', content.length);

          // If parse error and not last attempt, retry with more tokens
          if (attempts < MAX_ATTEMPTS) {
            const newTokens = Math.min(8192, Math.floor(outlineTokens * 1.3));
            console.log(`üîÑ Parse failed, retrying with ${newTokens} tokens...`);
            outlineTokens = newTokens;
            await new Promise(r => setTimeout(r, 1000));
            continue;
          }

          // Last attempt failed
          throw new Error(`Failed to parse outline: ${parseError.message}\n\nResponse c√≥ th·ªÉ b·ªã truncate. Th·ª≠ gi·∫£m s·ªë panels xu·ªëng.`);
        }
      }

      // Should never reach here, but just in case
      throw new Error('Outline generation failed after all retries');
    }

    // SERIES MODE: Generate HIGH-LEVEL ROADMAP for entire series
    async function generateSeriesOutline() {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const selectedTone = EMOTIONAL_TONES.find(t => t.id === state.emotionalIntensity);
      const totalPanels = state.episodesPerSeries * state.panelsPerEpisode;

      console.log('üì∫ Generating SERIES ROADMAP...');
      console.log('Episodes:', state.episodesPerSeries);
      console.log('Panels per episode:', state.panelsPerEpisode);
      console.log('Total story panels:', totalPanels);

      // Build characters prompt
      let charactersPrompt = '';
      if (state.characters.length > 0) {
        charactersPrompt = '\n**NH√ÇN V·∫¨T (user ƒë·ªãnh nghƒ©a)**:\n';
        state.characters.forEach((char, i) => {
          charactersPrompt += `${i + 1}. ${char.name}: ${char.description}\n`;
        });
      }

      const characterGuidance = {
        romance: '2-3 nh√¢n v·∫≠t ch√≠nh',
        slice_of_life: '2-3 nh√¢n v·∫≠t ch√≠nh',
        drama: '2-3 nh√¢n v·∫≠t ch√≠nh',
        horror: '3-4 nh√¢n v·∫≠t',
        action: '4-6 nh√¢n v·∫≠t (main + supporting)',
        fantasy: '4-6 nh√¢n v·∫≠t (main + supporting)',
        mystery: '3-5 nh√¢n v·∫≠t',
        comedy: '2-4 nh√¢n v·∫≠t'
      };

      const charGuide = characterGuidance[state.genre] || '2-3 nh√¢n v·∫≠t ch√≠nh';

      const systemPrompt = `B·∫°n l√† chuy√™n gia l·∫≠p k·∫ø ho·∫°ch series truy·ªán tranh d√†i t·∫≠p (manhwa/webtoon).

NHI·ªÜM V·ª§: T·∫°o HIGH-LEVEL ROADMAP cho series ${state.episodesPerSeries} chap.

C·∫§U TR√öC SERIES:
- T·ªïng: ${state.episodesPerSeries} chap √ó ${state.panelsPerEpisode} panels = ${state.episodesPerSeries * state.panelsPerEpisode} panels
- M·ªói chap: ${state.panelsPerEpisode} panels (ng·∫Øn g·ªçn, d·ªÖ ƒë·ªçc tr√™n mobile)
${state.panelsPerEpisode <= 15 ? `
üì± V·ªöI CHAP NG·∫ÆN (${state.panelsPerEpisode} panels):
- M·ªói chap t·∫≠p trung V√ÄO M·ªòT S·ª∞ KI·ªÜN/SCENE ch√≠nh
- N·ªôi dung S√öC T√çCH nh∆∞ng ƒë·∫ßy ƒë·ªß √Ω nghƒ©a
- Chuy·ªÉn ti·∫øp gi·ªØa c√°c chap M·∫†CH L·∫†C
- Nhi·ªÅu cliffhangers h∆°n = gi·ªØ ƒë·ªôc gi·∫£ ƒë·ªçc ti·∫øp
- Chia story arc th√†nh nhi·ªÅu chap nh·ªè ƒë·ªÉ tƒÉng engagement` : ''}

QUAN TR·ªåNG:
- ƒê√¢y l√† ROADMAP t·ªïng qu√°t - plan structure to√†n series
- Focus: plot progression, cliffhangers, character arcs
- T·∫°o series G·∫¶N G≈®I, GAY C·∫§N ƒë·ªÉ gi·ªØ ƒë·ªôc gi·∫£

üé≠ K·ª∏ THU·∫¨T THU H√öT ƒê·ªòC GI·∫¢ (√ÅP D·ª§NG T·ª∞ NHI√äN, H·ª¢P L√ù):

‚ö†Ô∏è QUAN TR·ªåNG: C√°c y·∫øu t·ªë d∆∞·ªõi ƒë√¢y ph·∫£i ORGANIC, ph·ª•c v·ª• c·ªët truy·ªán, KH√îNG g∆∞·ª£ng √©p!

1. **B√ç M·∫¨T & T√í M√í (Mysteries)** - Ch·ªâ khi PH√ô H·ª¢P v·ªõi th·ªÉ lo·∫°i:
   - C√†i c·∫Øm 1-2 b√≠ m·∫≠t/c√¢u h·ªèi ph√°t tri·ªÉn T·ª∞ NHI√äN t·ª´ c·ªët truy·ªán
   - H√© l·ªô d·∫ßn d·∫ßn theo nh·ªãp ph√π h·ª£p, kh√¥ng k√©o d√†i v√¥ l√Ω
   - VD h·ª£p l√Ω: Qu√° kh·ª© b√≠ ·∫©n ƒë∆∞·ª£c reveal khi nh√¢n v·∫≠t ƒë·ªëi m·∫∑t th·ª≠ th√°ch

2. **TWIST & REVELATION** - Ch·ªâ khi c√≥ LOGIC:
   - Twist ph·∫£i c√≥ foreshadowing (b√°o hi·ªáu tr∆∞·ªõc), kh√¥ng r∆°i t·ª´ tr·ªùi
   - Ph·∫£i h·ª£p l√Ω v·ªõi t√≠nh c√°ch nh√¢n v·∫≠t v√† logic c√¢u chuy·ªán
   - KH√îNG l·∫°m d·ª•ng: 1-2 twist l·ªõn cho c·∫£ series l√† ƒë·ªß

3. **EMOTIONAL MOMENTS** - T·ª± nhi√™n, kh√¥ng melodrama:
   - C·∫£m x√∫c ph√°t tri·ªÉn t·ª´ h√†nh tr√¨nh nh√¢n v·∫≠t, kh√¥ng √©p bu·ªôc
   - Xung ƒë·ªôt n·ªôi t√¢m ph·∫£i c√≥ nguy√™n nh√¢n r√µ r√†ng
   - Tr√°nh drama v√¥ nghƒ©a, ∆∞u ti√™n ph√°t tri·ªÉn nh√¢n v·∫≠t

4. **CLIFFHANGERS** - C√≥ ch·ª´ng m·ª±c:
   - K·∫øt th√∫c episode t·∫°o mong ƒë·ª£i nh∆∞ng KH√îNG th·∫•t v·ªçng khi gi·∫£i quy·∫øt
   - Ph·∫£i tr·∫£ l·ªùi ƒë∆∞·ª£c ·ªü episode sau, kh√¥ng b·ªè l·ª≠ng
   - M·ªôt s·ªë episode c√≥ th·ªÉ k·∫øt th√∫c nh·∫π nh√†ng, kh√¥ng c·∫ßn drama

5. **PACING T·ª∞ NHI√äN**:
   - Xen k·∫Ω moments cƒÉng th·∫≥ng v·ªõi moments nh·∫π nh√†ng
   - Kh√¥ng d·ªìn d·∫≠p shock li√™n t·ª•c ‚Üí g√¢y m·ªát m·ªèi cho ƒë·ªôc gi·∫£
   - ƒê·ªÉ c√¢u chuy·ªán "th·ªü" v√† nh√¢n v·∫≠t ph√°t tri·ªÉn

L∆ØU √ù V·ªÄ NH√ÇN V·∫¨T:
- Ch·ªâ c·∫ßn m√¥ t·∫£ NGO·∫†I H√åNH C∆† B·∫¢N (age, gender, hair, eyes, body type, trang ph·ª•c M·∫∂C ƒê·ªäNH)
- KH√îNG c·∫ßn m√¥ t·∫£ chi ti·∫øt trang ph·ª•c theo t·ª´ng scene
- Chi ti·∫øt trang ph·ª•c theo context s·∫Ω ƒë∆∞·ª£c th√™m ·ªü stage generatePanelDetail

ART STYLE GUIDE (cho to√†n b·ªô series):
- Ki·ªÉu v·∫Ω: ${selectedStyle.name}
- M√†u s·∫Øc: ${selectedColorMode.name}
- √Ånh s√°ng: ${selectedLighting.name}

FORMAT OUTPUT: JSON thu·∫ßn, KH√îNG markdown backticks`;

      const userPrompt = `T·∫°o SERIES OUTLINE cho series ${state.episodesPerSeries} episodes, th·ªÉ lo·∫°i: ${selectedGenre.name}

${charactersPrompt || `\n**L∆ØU √ù**: User ch∆∞a ƒë·ªãnh nghƒ©a nh√¢n v·∫≠t. H√ÉY T·ª∞ ƒê·ªòNG T·∫†O ${charGuide}.`}

√ù t∆∞·ªüng: ${state.storyPrompt || 'T·ª± do s√°ng t·∫°o m·ªôt c√¢u chuy·ªán h·∫•p d·∫´n, ƒë·∫ßy c·∫£m x√∫c v·ªõi twist b·∫•t ng·ªù'}

**EMOTIONAL TONE**: ${selectedTone.name}

**Y√äU C·∫¶U**:
- To√†n b·ªô series: ${totalPanels} panels (${state.episodesPerSeries} episodes √ó ${state.panelsPerEpisode} panels)
- M·ªói episode: C√≥ arc ri√™ng NH∆ØNG k·∫øt n·ªëi v·ªõi nhau
- Episode 1: Setup + Hook + Cliffhanger
- Episodes 2-${state.episodesPerSeries - 1}: Development + Rising Action + Cliffhanger
- Episode ${state.episodesPerSeries}: Climax + Resolution (NO cliffhanger)

Tr·∫£ v·ªÅ JSON:
{
  "series_title": "Ti√™u ƒë·ªÅ series H·∫§P D·∫™N, g·ª£i t√≤ m√≤",
  "series_synopsis": "T√≥m t·∫Øt to√†n b·ªô series (3-4 c√¢u) - ph·∫£i c√≥ HOOK thu h√∫t",
  "theme": "Ch·ªß ƒë·ªÅ ch√≠nh",
  "series_mysteries": [
    "B√≠ m·∫≠t l·ªõn #1 s·∫Ω h√© l·ªô d·∫ßn qua series (VD: Ai l√† k·∫ª gi·∫•u m·∫∑t?)",
    "B√≠ m·∫≠t l·ªõn #2 (VD: S·ª©c m·∫°nh th·∫≠t s·ª± c·ªßa nh√¢n v·∫≠t ch√≠nh)",
    "B√≠ m·∫≠t l·ªõn #3 (VD: M·ªëi quan h·ªá b√≠ ·∫©n gi·ªØa 2 nh√¢n v·∫≠t)"
  ],
  "foreshadowing_elements": [
    "Chi ti·∫øt c√†i c·∫Øm s·∫Ω payoff sau (VD: Chi·∫øc nh·∫´n b√≠ ·∫©n ·ªü ep1 ‚Üí reveal ·ªü ep5)"
  ],
  "characters": [
    {
      "name": "T√™n",
      "role": "protagonist/antagonist/supporting",
      "personality": "T√≠nh c√°ch (3-5 t·ª´)",
      "visual_description": "Age, gender, hair (color/style), eyes (color), height, body type, clothing (colors/style), 1-2 accessories",
      "character_arc": "S·ª± thay ƒë·ªïi/ph√°t tri·ªÉn qua series",
      "secret": "B√≠ m·∫≠t c·ªßa nh√¢n v·∫≠t n√†y (n·∫øu c√≥) - s·∫Ω reveal khi n√†o?"
    }
  ],
  "episodes": [
    {
      "episode_number": 1,
      "episode_title": "Ti√™u ƒë·ªÅ episode G√ÇY T√í M√í",
      "episode_synopsis": "T√≥m t·∫Øt episode n√†y (2-3 c√¢u)",
      "story_beat": "Setup/Development/Rising Action/Climax/Resolution",
      "key_events": ["Event 1", "Event 2", "Event 3"],
      "shocking_moment": "T√¨nh ti·∫øt gi·∫≠t g√¢n/b·∫•t ng·ªù trong episode n√†y (n·∫øu c√≥)",
      "mystery_hint": "G·ª£i √Ω v·ªÅ b√≠ m·∫≠t n√†o ƒë∆∞·ª£c h√© l·ªô/c√†i c·∫Øm",
      "character_focus": "T√™n nh√¢n v·∫≠t ch√≠nh c·ªßa episode n√†y",
      "cliffhanger": "Cliffhanger M·∫†NH k·∫øt th√∫c episode - khi·∫øn ƒë·ªôc gi·∫£ PH·∫¢I ƒë·ªçc ti·∫øp",
      "emotional_peak": "C·∫£m x√∫c ƒë·ªânh ƒëi·ªÉm c·ªßa episode",
      "hook_question": "C√¢u h·ªèi ƒë·ªôc gi·∫£ s·∫Ω t·ª± h·ªèi sau episode n√†y"
    }
  ]
}`;

      const limits = getCurrentLimits();
      const seriesTokens = Math.min(limits.maxOutputTokens, state.episodesPerSeries * 600 + 2000);
      console.log('üìä Using API:', limits.name);
      console.log('üìä Series outline tokens allocated:', seriesTokens);

      const data = await callTextAPI(systemPrompt, userPrompt, {
        temperature: 0.85,
        max_tokens: seriesTokens
      });

      let content = data.choices[0].message.content;
      content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      content = content.replace(/^\uFEFF/, '');

      try {
        const parsed = JSON.parse(content);
        console.log('üì∫ Series outline:', parsed.series_title);
        console.log('üë• Characters:', parsed.characters?.length || 0);
        console.log('üì∫ Episodes:', parsed.episodes?.length || 0);
        return parsed;
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error:', parseError);
        throw new Error(`Failed to parse series outline: ${parseError.message}`);
      }
    }

    // ===========================================
    // CHUNKED SERIES GENERATION - For large series (50+ chapters)
    // ===========================================
    // Step 1: Generate series base info (title, synopsis, characters, main arcs)
    async function generateSeriesBaseInfo(progressCallback) {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const selectedTone = EMOTIONAL_TONES.find(t => t.id === state.emotionalIntensity);

      if (progressCallback) progressCallback('ƒêang t·∫°o th√¥ng tin c∆° b·∫£n series...');

      // Scale character count based on series length
      const totalEps = state.episodesPerSeries;
      const numArcs = Math.ceil(totalEps / 30);

      // Character scaling: more episodes = more characters
      const getCharacterCount = (genre, episodes) => {
        // Base count by genre
        const baseCount = {
          romance: { main: 2, supporting: 1, perArc: 1 },
          slice_of_life: { main: 2, supporting: 2, perArc: 1 },
          drama: { main: 3, supporting: 2, perArc: 2 },
          horror: { main: 2, supporting: 2, perArc: 2 },
          action: { main: 3, supporting: 3, perArc: 3 },
          fantasy: { main: 3, supporting: 4, perArc: 3 },
          mystery: { main: 2, supporting: 3, perArc: 2 },
          comedy: { main: 3, supporting: 2, perArc: 1 }
        };
        const base = baseCount[genre] || { main: 2, supporting: 2, perArc: 1 };

        // Scale up for longer series
        const scaleFactor = episodes > 100 ? 1.5 : (episodes > 50 ? 1.2 : 1);
        return {
          main: Math.round(base.main * scaleFactor),
          supporting: Math.round(base.supporting * scaleFactor),
          perArc: Math.round(base.perArc * scaleFactor)
        };
      };

      const charCount = getCharacterCount(state.genre, totalEps);
      const totalChars = charCount.main + charCount.supporting + (charCount.perArc * numArcs);
      const charGuide = `${charCount.main} nh√¢n v·∫≠t ch√≠nh + ${charCount.supporting} nh√¢n v·∫≠t ph·ª• xuy√™n su·ªët + ${charCount.perArc} nh√¢n v·∫≠t m·ªõi m·ªói arc (t·ªïng ~${totalChars} nh√¢n v·∫≠t)`;

      // Build characters prompt if user defined characters
      let charactersPrompt = '';
      if (state.characters && state.characters.length > 0) {
        charactersPrompt = '**NH√ÇN V·∫¨T ƒê√É ƒê·ªäNH NGHƒ®A:**\n' + state.characters.map(char =>
          `- ${char.name} (${char.role}): ${char.appearance}, T√≠nh c√°ch: ${char.personality}`
        ).join('\n');
      }

      const systemPrompt = `B·∫°n l√† chuy√™n gia l·∫≠p k·∫ø ho·∫°ch series truy·ªán tranh d√†i ${totalEps} chap.

NHI·ªÜM V·ª§: T·∫°o TH√îNG TIN C∆† B·∫¢N cho series (KH√îNG t·∫°o chi ti·∫øt t·ª´ng episode).

C·∫§U TR√öC:
- T·ªïng: ${totalEps} chap √ó ${state.panelsPerEpisode} panels
- Chia th√†nh ${numArcs} arc l·ªõn, m·ªói arc ~${Math.floor(totalEps / numArcs)} chap

ART STYLE (th·ªëng nh·∫•t to√†n series):
- Ki·ªÉu v·∫Ω: ${selectedStyle.name}
- M√†u s·∫Øc: ${selectedColorMode.name}
- √Ånh s√°ng: ${selectedLighting.name}

Tr·∫£ v·ªÅ JSON thu·∫ßn (KH√îNG markdown):`;

      const userPrompt = `T·∫°o th√¥ng tin c∆° b·∫£n cho series ${totalEps} chap, th·ªÉ lo·∫°i: ${selectedGenre.name}

${charactersPrompt || `**Y√äU C·∫¶U NH√ÇN V·∫¨T**: T·ª± ƒë·ªông t·∫°o ${charGuide}.`}

**H∆Ø·ªöNG D·∫™N T·∫†O NH√ÇN V·∫¨T ƒêA D·∫†NG**:
- Nh√¢n v·∫≠t CH√çNH (main): Xu·∫•t hi·ªán xuy√™n su·ªët, c√≥ character arc r√µ r√†ng
- Nh√¢n v·∫≠t PH·ª§ (recurring): Xu·∫•t hi·ªán th∆∞·ªùng xuy√™n, h·ªó tr·ª£/g√¢y kh√≥ khƒÉn cho nh√¢n v·∫≠t ch√≠nh
- Nh√¢n v·∫≠t ARC (arc_specific): M·ªói arc c√≥ th√™m nh√¢n v·∫≠t m·ªõi (ƒë·ªëi th·ªß, ƒë·ªìng minh, mentor, love interest ph·ª•...)
  VD: Arc 1 c√≥ villain A, Arc 2 c√≥ villain B m·∫°nh h∆°n, Arc 3 c√≥ mentor m·ªõi...

√ù t∆∞·ªüng: ${state.storyPrompt || 'T·ª± do s√°ng t·∫°o c√¢u chuy·ªán h·∫•p d·∫´n'}

Emotional Tone: ${selectedTone.name}

Tr·∫£ v·ªÅ JSON:
{
  "series_title": "Ti√™u ƒë·ªÅ series H·∫§P D·∫™N",
  "series_synopsis": "T√≥m t·∫Øt to√†n series 3-4 c√¢u v·ªõi HOOK thu h√∫t",
  "theme": "Ch·ªß ƒë·ªÅ ch√≠nh",
  "total_episodes": ${totalEps},
  "story_arcs": [
    {
      "arc_number": 1,
      "arc_name": "T√™n arc",
      "episodes_range": "1-${Math.floor(totalEps / numArcs)}",
      "arc_synopsis": "T√≥m t·∫Øt arc n√†y",
      "main_conflict": "Xung ƒë·ªôt ch√≠nh c·ªßa arc",
      "arc_climax": "Cao tr√†o c·ªßa arc",
      "new_characters": ["T√™n nh√¢n v·∫≠t m·ªõi xu·∫•t hi·ªán trong arc n√†y"]
    }
  ],
  "series_mysteries": [
    "B√≠ m·∫≠t l·ªõn #1 s·∫Ω reveal d·∫ßn",
    "B√≠ m·∫≠t l·ªõn #2"
  ],
  "foreshadowing_elements": [
    "Chi ti·∫øt c√†i c·∫Øm s·∫Ω payoff sau"
  ],
  "characters": [
    {
      "name": "T√™n",
      "role": "protagonist/antagonist/supporting/arc_specific",
      "character_type": "main/recurring/arc_villain/arc_ally/mentor/rival/love_interest",
      "introduced_in_arc": 1,
      "appears_until_arc": null,
      "personality": "T√≠nh c√°ch 3-5 t·ª´",
      "visual_description": "Age, gender, hair (color + style + length), eyes (color + shape), height, body type, default clothing v·ªõi m√†u s·∫Øc c·ª• th·ªÉ, accessories",
      "relationship_to_protagonist": "M·ªëi quan h·ªá v·ªõi nh√¢n v·∫≠t ch√≠nh",
      "character_arc": "S·ª± ph√°t tri·ªÉn qua series (ho·∫∑c arc)",
      "secret": "B√≠ m·∫≠t (n·∫øu c√≥)",
      "fate": "K·∫øt c·ª•c c·ªßa nh√¢n v·∫≠t (n·∫øu r·ªùi kh·ªèi truy·ªán)"
    }
  ]
}

**L∆ØU √ù QUAN TR·ªåNG**:
- Nh√¢n v·∫≠t main/recurring: introduced_in_arc = 1, appears_until_arc = null (xu·∫•t hi·ªán ƒë·∫øn h·∫øt)
- Nh√¢n v·∫≠t arc_specific: introduced_in_arc = s·ªë arc, appears_until_arc = s·ªë arc (ho·∫∑c null n·∫øu tr·ªü th√†nh recurring)
- M·ªói arc N√äN c√≥ √≠t nh·∫•t 1 nh√¢n v·∫≠t m·ªõi ƒë·ªÉ t·∫°o s·ª± t∆∞∆°i m·ªõi
- Villain c√≥ th·ªÉ thay ƒë·ªïi qua c√°c arc (level up)
- M·ªôt s·ªë nh√¢n v·∫≠t arc_specific c√≥ th·ªÉ "ch·∫øt" ho·∫∑c r·ªùi ƒëi sau arc c·ªßa h·ªç`;

      // Scale tokens based on character count and arcs
      const baseInfoTokens = Math.min(12000, 4000 + (totalChars * 200) + (numArcs * 300));

      const data = await callTextAPI(systemPrompt, userPrompt, {
        temperature: 0.85,
        max_tokens: baseInfoTokens,
        provider: 'gemini' // Always use Gemini for base info
      });

      let content = data.choices[0].message.content;
      content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      content = content.replace(/^\uFEFF/, '');

      return JSON.parse(content);
    }

    // Step 2: Generate episodes in chunks (15-20 episodes per chunk)
    async function generateEpisodesChunk(baseInfo, startEp, endEp, progressCallback) {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);

      const chunkSize = endEp - startEp + 1;
      if (progressCallback) progressCallback(`ƒêang t·∫°o chap ${startEp}-${endEp}...`);

      console.log(`\nüì¶ Generating episodes chunk: ${startEp} to ${endEp} (${chunkSize} episodes)`);

      // Find which arc this chunk belongs to
      const relevantArcs = baseInfo.story_arcs?.filter(arc => {
        const [arcStart, arcEnd] = arc.episodes_range.split('-').map(Number);
        return !(endEp < arcStart || startEp > arcEnd);
      }) || [];

      // Get current arc number for character filtering
      const currentArcNumbers = relevantArcs.map(arc => arc.arc_number);
      const maxArcNumber = Math.max(...currentArcNumbers, 1);

      const arcContext = relevantArcs.map(arc =>
        `Arc "${arc.arc_name}" (Chap ${arc.episodes_range}): ${arc.arc_synopsis}` +
        (arc.new_characters?.length ? `\n  ‚Üí Nh√¢n v·∫≠t m·ªõi: ${arc.new_characters.join(', ')}` : '')
      ).join('\n');

      // Filter characters by arc: only include characters that have been introduced by this arc
      // and haven't left the story yet
      const activeCharacters = baseInfo.characters.filter(char => {
        const introducedIn = char.introduced_in_arc || 1;
        const appearsUntil = char.appears_until_arc || 999;
        return introducedIn <= maxArcNumber && appearsUntil >= Math.min(...currentArcNumbers);
      });

      // Group characters by type for better context
      const mainChars = activeCharacters.filter(c => c.character_type === 'main' || c.role === 'protagonist');
      const recurringChars = activeCharacters.filter(c => c.character_type === 'recurring' || c.role === 'supporting');
      const arcChars = activeCharacters.filter(c => c.character_type?.startsWith('arc_') || c.role === 'arc_specific');

      const characterDescriptions = [
        mainChars.length ? `**NH√ÇN V·∫¨T CH√çNH:**\n${mainChars.map(char => `- ${char.name} (${char.role}): ${char.visual_description}`).join('\n')}` : '',
        recurringChars.length ? `**NH√ÇN V·∫¨T PH·ª§:**\n${recurringChars.map(char => `- ${char.name}: ${char.visual_description}`).join('\n')}` : '',
        arcChars.length ? `**NH√ÇN V·∫¨T ARC N√ÄY:**\n${arcChars.map(char => `- ${char.name} (${char.character_type || char.role}): ${char.visual_description}`).join('\n')}` : ''
      ].filter(Boolean).join('\n\n');

      const systemPrompt = `B·∫°n l√† chuy√™n gia vi·∫øt outline chi ti·∫øt cho series truy·ªán tranh.

NHI·ªÜM V·ª§: T·∫°o outline cho CHAP ${startEp} ƒë·∫øn ${endEp} (${chunkSize} chap).

QUAN TR·ªåNG - PH·∫¢I T·∫†O ƒê·∫¶Y ƒê·ª¶ ${chunkSize} EPISODES:
‚ö†Ô∏è KH√îNG ƒë∆∞·ª£c b·ªè qua episode n√†o!
‚ö†Ô∏è KH√îNG ƒë∆∞·ª£c t√≥m t·∫Øt nhi·ªÅu episode th√†nh m·ªôt!
‚ö†Ô∏è M·ªói episode PH·∫¢I c√≥ ƒë·∫ßy ƒë·ªß th√¥ng tin ri√™ng bi·ªát!

SERIES INFO:
- Title: ${baseInfo.series_title}
- Theme: ${baseInfo.theme}
- Synopsis: ${baseInfo.series_synopsis}
${baseInfo.series_mysteries ? `- Mysteries: ${baseInfo.series_mysteries.join('; ')}` : ''}

STORY ARCS:
${arcContext || 'N/A'}

CHARACTERS:
${characterDescriptions}

ART STYLE (th·ªëng nh·∫•t):
- Style: ${selectedStyle.name}
- Color: ${selectedColorMode.name}
- Lighting: ${selectedLighting.name}

Tr·∫£ v·ªÅ JSON array thu·∫ßn (KH√îNG markdown):`;

      const isFirstChunk = startEp === 1;
      const isLastChunk = endEp === state.episodesPerSeries;

      const userPrompt = `T·∫°o outline CHI TI·∫æT cho T·ª™NG CHAP t·ª´ ${startEp} ƒë·∫øn ${endEp}.

‚ö†Ô∏è B·∫ÆT BU·ªòC: Ph·∫£i tr·∫£ v·ªÅ ƒê√öNG ${chunkSize} episodes, m·ªói episode m·ªôt object ri√™ng!

${isFirstChunk ? 'üìñ ƒê√¢y l√† CHUNK ƒê·∫¶U TI√äN - Setup characters, world, v√† main conflict' : ''}
${isLastChunk ? 'üé¨ ƒê√¢y l√† CHUNK CU·ªêI - Climax v√† Resolution cho to√†n series' : ''}

**L∆ØU √ù V·ªÄ NH√ÇN V·∫¨T**:
- KH√îNG ph·∫£i t·∫•t c·∫£ nh√¢n v·∫≠t xu·∫•t hi·ªán trong m·ªçi chap
- M·ªói chap ch·ªâ focus v√†o m·ªôt s·ªë nh√¢n v·∫≠t nh·∫•t ƒë·ªãnh
- Nh√¢n v·∫≠t arc_specific ch·ªâ xu·∫•t hi·ªán trong arc c·ªßa h·ªç
- C√≥ th·ªÉ gi·ªõi thi·ªáu nh√¢n v·∫≠t ph·ª• m·ªõi trong chap quan tr·ªçng

Tr·∫£ v·ªÅ JSON array (${chunkSize} objects):
[
  {
    "episode_number": ${startEp},
    "episode_title": "Ti√™u ƒë·ªÅ chap ${startEp}",
    "episode_synopsis": "T√≥m t·∫Øt chap n√†y 2-3 c√¢u",
    "story_beat": "Setup/Development/Rising Action/Climax/Resolution",
    "key_events": ["Event 1", "Event 2", "Event 3"],
    "characters_appearing": ["T√™n nh√¢n v·∫≠t 1", "T√™n nh√¢n v·∫≠t 2"],
    "new_character_intro": "N·∫øu c√≥ nh√¢n v·∫≠t m·ªõi ƒë∆∞·ª£c gi·ªõi thi·ªáu trong chap n√†y, m√¥ t·∫£ ng·∫Øn",
    "shocking_moment": "T√¨nh ti·∫øt gi·∫≠t g√¢n n·∫øu c√≥",
    "mystery_hint": "G·ª£i √Ω b√≠ m·∫≠t ƒë∆∞·ª£c h√© l·ªô/c√†i c·∫Øm",
    "character_focus": "Nh√¢n v·∫≠t ch√≠nh c·ªßa chap",
    "character_development": "S·ª± ph√°t tri·ªÉn c·ªßa nh√¢n v·∫≠t trong chap",
    "cliffhanger": "Cliffhanger k·∫øt th√∫c chap",
    "emotional_peak": "C·∫£m x√∫c ƒë·ªânh ƒëi·ªÉm",
    "hook_question": "C√¢u h·ªèi ƒë·ªôc gi·∫£ s·∫Ω t·ª± h·ªèi"
  },
  {
    "episode_number": ${startEp + 1},
    "episode_title": "Ti√™u ƒë·ªÅ chap ${startEp + 1}",
    ...
  },
  ... ti·∫øp t·ª•c cho T·∫§T C·∫¢ ${chunkSize} episodes t·ª´ ${startEp} ƒë·∫øn ${endEp}
]`;

      // Calculate tokens needed: ~1000 tokens per episode (detailed outline)
      const tokensNeeded = chunkSize * 1200 + 1000;

      const data = await callTextAPI(systemPrompt, userPrompt, {
        temperature: 0.85,
        max_tokens: Math.min(tokensNeeded, 65000),
        provider: 'gemini' // Use Gemini for chunk generation
      });

      let content = data.choices[0].message.content;
      content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      content = content.replace(/^\uFEFF/, '');

      const episodes = JSON.parse(content);

      // Validate chunk
      if (!Array.isArray(episodes)) {
        throw new Error(`Expected array of episodes, got: ${typeof episodes}`);
      }

      console.log(`‚úÖ Chunk ${startEp}-${endEp}: Received ${episodes.length} episodes`);

      // Fill in any missing episodes
      const result = [];
      for (let i = startEp; i <= endEp; i++) {
        const ep = episodes.find(e => e.episode_number === i);
        if (ep) {
          result.push(ep);
        } else {
          console.warn(`‚ö†Ô∏è Episode ${i} missing, creating placeholder`);
          result.push({
            episode_number: i,
            episode_title: `Chap ${i}`,
            episode_synopsis: `Ti·∫øp t·ª•c c√¢u chuy·ªán...`,
            story_beat: 'Development',
            key_events: ['Continuing story'],
            cliffhanger: 'To be continued...',
            emotional_peak: 'Tension',
            character_focus: baseInfo.characters[0]?.name || 'Main character'
          });
        }
      }

      return result;
    }

    // Step 3: Main chunked generation orchestrator
    async function generateSeriesOutlineChunked(progressCallback) {
      console.log('\nüöÄ Starting CHUNKED series generation...');
      console.log(`üìä Total episodes: ${state.episodesPerSeries}`);

      // Check if Gemini key is available
      if (!state.geminiKey) {
        throw new Error('Hybrid mode c·∫ßn API key Gemini 3 Pro. Vui l√≤ng th√™m key trong API Setup.');
      }

      // Step 1: Generate base info
      if (progressCallback) progressCallback('B∆∞·ªõc 1/2: T·∫°o th√¥ng tin series...');
      const baseInfo = await generateSeriesBaseInfo(progressCallback);
      console.log('‚úÖ Base info generated:', baseInfo.series_title);

      // Step 2: Generate episodes in chunks of 15
      const CHUNK_SIZE = 15;
      const totalEps = state.episodesPerSeries;
      const numChunks = Math.ceil(totalEps / CHUNK_SIZE);
      const allEpisodes = [];
      const failedBatches = [];

      if (progressCallback) progressCallback(`B∆∞·ªõc 2/2: T·∫°o ${totalEps} chap (${numChunks} batches)...`);

      for (let i = 0; i < numChunks; i++) {
        const startEp = i * CHUNK_SIZE + 1;
        const endEp = Math.min((i + 1) * CHUNK_SIZE, totalEps);

        if (progressCallback) {
          progressCallback(`Batch ${i + 1}/${numChunks}: Chap ${startEp}-${endEp}...`);
        }

        try {
          const chunkEpisodes = await generateEpisodesChunk(baseInfo, startEp, endEp, progressCallback);
          allEpisodes.push(...chunkEpisodes);
          console.log(`‚úÖ Batch ${i + 1}/${numChunks} complete: ${chunkEpisodes.length} episodes`);
        } catch (error) {
          console.error(`‚ùå Error in batch ${i + 1}:`, error);
          // Track failed batch for retry
          failedBatches.push({
            batchNumber: i + 1,
            startEp,
            endEp,
            error: error.message
          });
        }

        // Small delay between chunks to avoid rate limiting
        if (i < numChunks - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      // Store failed batches in state for retry
      state.failedBatches = failedBatches;

      // Combine into final outline
      const finalOutline = {
        series_title: baseInfo.series_title,
        series_synopsis: baseInfo.series_synopsis,
        theme: baseInfo.theme,
        story_arcs: baseInfo.story_arcs,
        series_mysteries: baseInfo.series_mysteries,
        foreshadowing_elements: baseInfo.foreshadowing_elements,
        characters: baseInfo.characters,
        episodes: allEpisodes.sort((a, b) => a.episode_number - b.episode_number)
      };

      console.log('\n‚úÖ CHUNKED generation complete!');
      console.log(`üì∫ Total episodes: ${finalOutline.episodes.length}`);
      console.log(`üë• Characters: ${finalOutline.characters.length}`);
      if (failedBatches.length > 0) {
        console.log(`‚ö†Ô∏è Failed batches: ${failedBatches.length}`);
      }

      return finalOutline;
    }

    // Retry failed batches
    async function retryFailedBatches() {
      if (state.failedBatches.length === 0 || !state.seriesOutline) {
        alert('Kh√¥ng c√≥ batch n√†o c·∫ßn retry!');
        return;
      }

      state.isRetrying = true;
      state.loadingMessage = 'ƒêang retry c√°c batch b·ªã l·ªói...';
      render();

      const baseInfo = {
        series_title: state.seriesOutline.series_title,
        series_synopsis: state.seriesOutline.series_synopsis,
        theme: state.seriesOutline.theme,
        story_arcs: state.seriesOutline.story_arcs,
        series_mysteries: state.seriesOutline.series_mysteries,
        foreshadowing_elements: state.seriesOutline.foreshadowing_elements,
        characters: state.seriesOutline.characters
      };

      const successfulRetries = [];
      const stillFailed = [];

      for (let i = 0; i < state.failedBatches.length; i++) {
        const batch = state.failedBatches[i];
        state.loadingMessage = `Retry batch ${i + 1}/${state.failedBatches.length}: Chap ${batch.startEp}-${batch.endEp}...`;
        render();

        try {
          console.log(`\nüîÑ Retrying batch: Chap ${batch.startEp}-${batch.endEp}...`);
          const chunkEpisodes = await generateEpisodesChunk(baseInfo, batch.startEp, batch.endEp, null);

          // Add to existing episodes
          const existingEpNumbers = state.seriesOutline.episodes.map(e => e.episode_number);
          const newEpisodes = chunkEpisodes.filter(e => !existingEpNumbers.includes(e.episode_number));
          state.seriesOutline.episodes.push(...newEpisodes);
          state.seriesOutline.episodes.sort((a, b) => a.episode_number - b.episode_number);

          successfulRetries.push(batch);
          console.log(`‚úÖ Retry successful: Chap ${batch.startEp}-${batch.endEp}`);
        } catch (error) {
          console.error(`‚ùå Retry failed: Chap ${batch.startEp}-${batch.endEp}`, error);
          stillFailed.push({
            ...batch,
            error: error.message
          });
        }

        // Small delay between retries
        if (i < state.failedBatches.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
      }

      state.failedBatches = stillFailed;
      state.isRetrying = false;
      state.loadingMessage = '';

      if (successfulRetries.length > 0) {
        // Auto-save after retry
        saveCurrentStory(true);
      }

      render();

      if (stillFailed.length === 0) {
        alert(`‚úÖ T·∫•t c·∫£ ${successfulRetries.length} batch ƒë√£ retry th√†nh c√¥ng!`);
      } else {
        alert(`‚ö†Ô∏è Retry: ${successfulRetries.length} th√†nh c√¥ng, ${stillFailed.length} v·∫´n l·ªói`);
      }
    }

    // Regenerate missing episodes (for when failedBatches is empty but episodes are missing)
    async function regenerateMissingEpisodes() {
      if (!state.seriesOutline) {
        alert('Kh√¥ng c√≥ series outline!');
        return;
      }

      // Find missing episode numbers
      const existingEpNumbers = state.seriesOutline.episodes.map(e => e.episode_number);
      const expectedEps = Array.from({ length: state.episodesPerSeries }, (_, i) => i + 1);
      const missingEps = expectedEps.filter(n => !existingEpNumbers.includes(n));

      if (missingEps.length === 0) {
        alert('Kh√¥ng c√≥ episode n√†o b·ªã thi·∫øu!');
        return;
      }

      // Group missing episodes into batches of 5
      const batches = [];
      let currentBatch = [];
      for (let i = 0; i < missingEps.length; i++) {
        if (currentBatch.length === 0) {
          currentBatch.push(missingEps[i]);
        } else if (missingEps[i] === currentBatch[currentBatch.length - 1] + 1 && currentBatch.length < 5) {
          // Consecutive and batch not full
          currentBatch.push(missingEps[i]);
        } else {
          // Start new batch
          batches.push({
            startEp: currentBatch[0],
            endEp: currentBatch[currentBatch.length - 1]
          });
          currentBatch = [missingEps[i]];
        }
      }
      // Don't forget last batch
      if (currentBatch.length > 0) {
        batches.push({
          startEp: currentBatch[0],
          endEp: currentBatch[currentBatch.length - 1]
        });
      }

      console.log(`üîÑ Regenerating ${missingEps.length} missing episodes in ${batches.length} batches`);

      state.isRetrying = true;
      state.loadingMessage = `ƒêang t√°i t·∫°o ${missingEps.length} episode b·ªã thi·∫øu...`;
      render();

      const baseInfo = {
        series_title: state.seriesOutline.series_title,
        series_synopsis: state.seriesOutline.series_synopsis,
        theme: state.seriesOutline.theme,
        story_arcs: state.seriesOutline.story_arcs,
        series_mysteries: state.seriesOutline.series_mysteries,
        foreshadowing_elements: state.seriesOutline.foreshadowing_elements,
        characters: state.seriesOutline.characters
      };

      let successCount = 0;
      const newFailedBatches = [];

      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        state.loadingMessage = `T√°i t·∫°o batch ${i + 1}/${batches.length}: Chap ${batch.startEp}-${batch.endEp}...`;
        render();

        try {
          console.log(`\nüîÑ Generating missing batch: Chap ${batch.startEp}-${batch.endEp}...`);
          const chunkEpisodes = await generateEpisodesChunk(baseInfo, batch.startEp, batch.endEp, null);

          // Add to existing episodes (avoid duplicates)
          const currentEpNumbers = state.seriesOutline.episodes.map(e => e.episode_number);
          const newEpisodes = chunkEpisodes.filter(e => !currentEpNumbers.includes(e.episode_number));
          state.seriesOutline.episodes.push(...newEpisodes);
          state.seriesOutline.episodes.sort((a, b) => a.episode_number - b.episode_number);

          successCount += newEpisodes.length;
          console.log(`‚úÖ Generated ${newEpisodes.length} episodes for batch ${batch.startEp}-${batch.endEp}`);
        } catch (error) {
          console.error(`‚ùå Failed to generate batch ${batch.startEp}-${batch.endEp}:`, error);
          newFailedBatches.push({
            batchNumber: i + 1,
            startEp: batch.startEp,
            endEp: batch.endEp,
            error: error.message
          });
        }

        // Delay between batches
        if (i < batches.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }

      state.failedBatches = newFailedBatches;
      state.isRetrying = false;
      state.loadingMessage = '';

      if (successCount > 0) {
        // Auto-save after regeneration
        saveCurrentStory(true);
      }

      render();

      if (newFailedBatches.length === 0) {
        alert(`‚úÖ ƒê√£ t√°i t·∫°o th√†nh c√¥ng ${successCount} episode!`);
      } else {
        alert(`‚ö†Ô∏è T√°i t·∫°o: ${successCount} th√†nh c√¥ng, ${newFailedBatches.length} batch v·∫´n l·ªói`);
      }
    }

    // SERIES MODE: Generate OUTLINE for ONE episode (panel summaries only)
    async function generateEpisodeOutline(seriesOutline, episodeIndex) {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const selectedTone = EMOTIONAL_TONES.find(t => t.id === state.emotionalIntensity);

      const episode = seriesOutline.episodes[episodeIndex];
      const prevEpisode = episodeIndex > 0 ? seriesOutline.episodes[episodeIndex - 1] : null;

      console.log(`\nüì∫ Generating Episode ${episode.episode_number} OUTLINE: ${episode.episode_title}`);

      // Build previous episode context
      let previousContext = '';
      if (prevEpisode && state.episodes[episodeIndex - 1]) {
        const prevEpData = state.episodes[episodeIndex - 1];
        const lastPanel = prevEpData.panels[prevEpData.panels.length - 1];
        previousContext = `\n**PREVIOUS EPISODE RECAP**:
Episode ${prevEpisode.episode_number}: "${prevEpisode.episode_title}"
Cliffhanger: ${prevEpisode.cliffhanger}
Last scene: ${lastPanel?.panelData?.scene_description || 'N/A'}
Last dialogue: ${lastPanel?.panelData?.dialogue || 'N/A'}`;
      }

      // Character descriptions
      const characterDescriptions = seriesOutline.characters.map(char =>
        `${char.name} (${char.role}): ${char.visual_description}`
      ).join('\n');

      const systemPrompt = `B·∫°n l√† chuy√™n gia vi·∫øt outline chi ti·∫øt cho episode truy·ªán tranh series.

NHI·ªÜM V·ª§: T·∫°o OUTLINE cho Chap ${episode.episode_number} v·ªõi ${state.panelsPerEpisode} panel summaries.

SERIES CONTEXT:
- Series: ${seriesOutline.series_title}
- Theme: ${seriesOutline.theme}
- Chap: ${episode.episode_number}/${seriesOutline.episodes.length}
${seriesOutline.series_mysteries ? `- Series Mysteries: ${seriesOutline.series_mysteries.join(', ')}` : ''}

${state.panelsPerEpisode <= 15 ? `
üì± CHAP NG·∫ÆN (${state.panelsPerEpisode} panels) - QUY T·∫ÆC:
- T·∫≠p trung V√ÄO M·ªòT S·ª∞ KI·ªÜN/SCENE ch√≠nh cho chap n√†y
- M·ªói panel ph·∫£i c√≥ √ù NGHƒ®A, kh√¥ng c√≥ panel th·ª´a
- N·ªôi dung S√öC T√çCH nh∆∞ng ƒë·∫ßy ƒë·ªß ƒë·ªÉ hi·ªÉu context
- Chuy·ªÉn ti·∫øp M·∫†CH L·∫†C: panel n√†y ‚Üí panel ti·∫øp theo t·ª± nhi√™n
- K·∫øt th√∫c chap t·∫°o MONG ƒê·ª¢I cho chap sau` : ''}

‚ö†Ô∏è CRITICAL - BE CONCISE:
- M·ªói panel summary: 1-2 c√¢u ng·∫Øn g·ªçn (10-15 t·ª´)
- Focus: key action, emotion, progression

üé≠ K·ª∏ THU·∫¨T THU H√öT ƒê·ªòC GI·∫¢ (T·ª∞ NHI√äN, KH√îNG G∆Ø·ª¢NG √âP):

‚ö†Ô∏è QUAN TR·ªåNG: C√°c y·∫øu t·ªë ph·∫£i ORGANIC, h·ª£p logic v·ªõi c·ªët truy·ªán!

1. **OPENING T·ª∞ NHI√äN**:
   - N·∫øu episode tr∆∞·ªõc c√≥ cliffhanger ‚Üí gi·∫£i quy·∫øt/ti·∫øp n·ªëi H·ª¢P L√ù
   - N·∫øu kh√¥ng ‚Üí m·ªü ƒë·∫ßu t·ª± nhi√™n, thi·∫øt l·∫≠p b·ªëi c·∫£nh episode

2. **PH√ÅT TRI·ªÇN C√ÇU CHUY·ªÜN** (pacing t·ª± nhi√™n):
   - Panel 1-${Math.floor(state.panelsPerEpisode * 0.3)}: Setup, gi·ªõi thi·ªáu conflict c·ªßa episode
   - Panel ${Math.floor(state.panelsPerEpisode * 0.3)}-${Math.floor(state.panelsPerEpisode * 0.7)}: Ph√°t tri·ªÉn, x√¢y d·ª±ng tension
   - Panel ${Math.floor(state.panelsPerEpisode * 0.7)}-${state.panelsPerEpisode}: Climax + k·∫øt th√∫c episode

3. **C√ÇU H·ªéI/B√ç M·∫¨T** (n·∫øu PH√ô H·ª¢P v·ªõi episode plan):
   - H√© l·ªô ho·∫∑c c√†i c·∫Øm theo nh·ªãp T·ª∞ NHI√äN
   - Kh√¥ng √©p m·ªçi episode ƒë·ªÅu ph·∫£i c√≥ twist

4. **C·∫¢M X√öC CH√ÇN TH·ª∞C**: Ph√°t tri·ªÉn t·ª´ h√†nh tr√¨nh nh√¢n v·∫≠t, kh√¥ng melodrama

5. **K·∫æT TH√öC PH√ô H·ª¢P**:
   - N·∫øu episode plan y√™u c·∫ßu cliffhanger ‚Üí t·∫°o cliffhanger H·ª¢P L√ù
   - N·∫øu kh√¥ng ‚Üí c√≥ th·ªÉ k·∫øt nh·∫π nh√†ng, ƒë·ªÉ c√¢u chuy·ªán "th·ªü"

ART STYLE: ${selectedStyle.name} | ${selectedColorMode.name} | ${selectedLighting.name}

FORMAT OUTPUT: JSON thu·∫ßn, KH√îNG markdown backticks`;

      const userPrompt = `T·∫°o OUTLINE cho Episode ${episode.episode_number}: "${episode.episode_title}"

**SERIES**:
${seriesOutline.series_synopsis}
${previousContext}

**CHARACTERS**:
${characterDescriptions}

**THIS EPISODE PLAN**:
Synopsis: ${episode.episode_synopsis}
Story beat: ${episode.story_beat}
Key events: ${episode.key_events.join(', ')}
${episode.plot_twists?.length ? `Plot twists: ${episode.plot_twists.join(', ')}` : ''}
Character focus: ${episode.character_focus}
${episode.cliffhanger ? `Must end with: ${episode.cliffhanger}` : 'FINAL EPISODE - satisfying resolution'}
Emotional peak: ${episode.emotional_peak}

**Y√äU C·∫¶U ${state.panelsPerEpisode} PANELS**:
${state.panelsPerEpisode <= 15 ? `
üì± CHAP NG·∫ÆN - M·ªói panel ph·∫£i c√≥ √ù NGHƒ®A:
- Panel 1-2: ${previousContext ? 'Ti·∫øp n·ªëi t·ª´ chap tr∆∞·ªõc' : 'Opening hook'} + thi·∫øt l·∫≠p scene
- Panel 3-${Math.floor(state.panelsPerEpisode * 0.6)}: Ph√°t tri·ªÉn s·ª± ki·ªán ch√≠nh c·ªßa chap
- Panel ${Math.floor(state.panelsPerEpisode * 0.6) + 1}-${state.panelsPerEpisode - 1}: ƒê·∫©y l√™n cao tr√†o
- Panel ${state.panelsPerEpisode}: ${episode.cliffhanger ? 'Cliffhanger ‚Üí chap sau' : 'K·∫øt th√∫c th·ªèa m√£n'}` : `
- Panel 1: ${previousContext ? 'Ti·∫øp n·ªëi cliffhanger' : 'Strong opening hook'}
- Panels 2-${Math.floor(state.panelsPerEpisode * 0.25)}: Setup
- Panels ${Math.floor(state.panelsPerEpisode * 0.25) + 1}-${Math.floor(state.panelsPerEpisode * 0.6)}: Development
- Panels ${Math.floor(state.panelsPerEpisode * 0.6) + 1}-${state.panelsPerEpisode - 1}: Build tension + climax
- Panel ${state.panelsPerEpisode}: ${episode.cliffhanger ? 'DRAMATIC CLIFFHANGER' : 'Resolution ending'}`}

Tr·∫£ v·ªÅ JSON:
{
  "title": "${episode.episode_title}",
  "episode_number": ${episode.episode_number},
  "synopsis": "${episode.episode_synopsis}",
  "theme": "${seriesOutline.theme}",
  "characters": ${JSON.stringify(seriesOutline.characters)},
  "panel_summaries": [
    {
      "panel_number": 1,
      "summary": "M√¥ t·∫£ ng·∫Øn g·ªçn: location + character + action key (10-15 t·ª´)",
      "emotional_beat": "Emotion (1-2 t·ª´)",
      "story_note": "Role trong episode arc"
    }
  ]
}`;

      // In hybrid mode, use DeepSeek for episode outline (panel details)
      // This is the detailed work that DeepSeek excels at
      const providerForOutline = state.hybridMode ? 'deepseek' : state.textApiProvider;
      const limits = API_LIMITS[providerForOutline];
      const outlineTokens = Math.min(limits.maxOutputTokens, state.panelsPerEpisode * 120 + 1500);

      console.log('üìä Using API:', limits.name, state.hybridMode ? '(Hybrid Mode - DeepSeek for panels)' : '');
      console.log('üìä Episode outline tokens:', outlineTokens);

      // Use auto-retry logic (same as generateStoryOutline)
      let attempts = 0;
      const MAX_ATTEMPTS = 2;
      let allocatedTokens = outlineTokens;

      while (attempts < MAX_ATTEMPTS) {
        attempts++;
        console.log(`üîÑ Attempt ${attempts}/${MAX_ATTEMPTS}`);

        const data = await callTextAPI(systemPrompt, userPrompt, {
          temperature: 0.85,
          max_tokens: allocatedTokens,
          provider: providerForOutline // Use specified provider for hybrid mode
        });

        let content = data.choices[0].message.content;
        const finishReason = data.choices[0].finish_reason;

        console.log('‚öôÔ∏è Finish reason:', finishReason);

        if (finishReason === 'length' && attempts < MAX_ATTEMPTS) {
          allocatedTokens = Math.min(limits.maxOutputTokens, Math.floor(allocatedTokens * 1.3));
          console.log(`üîÑ Retrying with ${allocatedTokens} tokens...`);
          await new Promise(r => setTimeout(r, 1000));
          continue;
        }

        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        content = content.replace(/^\uFEFF/, '');

        try {
          const parsed = JSON.parse(content);
          console.log(`‚úÖ Episode ${episode.episode_number} outline generated`);
          console.log('üìÑ Panel summaries:', parsed.panel_summaries?.length || 0);
          return parsed;
        } catch (parseError) {
          console.error('‚ùå JSON Parse Error:', parseError);
          if (attempts < MAX_ATTEMPTS) {
            allocatedTokens = Math.min(limits.maxOutputTokens, Math.floor(allocatedTokens * 1.3));
            await new Promise(r => setTimeout(r, 1000));
            continue;
          }
          throw new Error(`Failed to parse episode outline: ${parseError.message}`);
        }
      }

      throw new Error('Episode outline generation failed after retries');
    }

    // Stage 2: Generate detailed panel info from outline
    async function generatePanelDetail(outline, panelIndex) {
      const selectedGenre = GENRES.find(g => g.id === state.genre);
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const selectedColorMode = COLOR_MODES.find(c => c.id === state.colorMode);
      const selectedLighting = LIGHTING_STYLES.find(l => l.id === state.lightingStyle);
      const panelSummary = outline.panel_summaries[panelIndex];

      // Build full character descriptions
      const characterDescriptions = outline.characters.map(char =>
        `${char.name} (${char.role}): ${char.visual_description}`
      ).join('\n');

      // Build context from surrounding panels
      const prevPanel = panelIndex > 0 ? outline.panel_summaries[panelIndex - 1] : null;
      const nextPanel = panelIndex < outline.panel_summaries.length - 1 ? outline.panel_summaries[panelIndex + 1] : null;

      // Art style guide - th·ªëng nh·∫•t xuy√™n su·ªët
      const styleGuide = `
ART STYLE GUIDE (B·∫ÆT BU·ªòC TU√ÇN TH·ª¶ CHO TO√ÄN B·ªò TRUY·ªÜN):
- Ki·ªÉu v·∫Ω: ${selectedStyle.name}
- M√†u s·∫Øc: ${selectedColorMode.name} - ${selectedColorMode.prompt}
- √Ånh s√°ng: ${selectedLighting.name} - ${selectedLighting.prompt}
‚ö†Ô∏è QUAN TR·ªåNG: Gi·ªØ NH·∫§T QU√ÅN style n√†y cho T·∫§T C·∫¢ panels!`;

      const systemPrompt = `B·∫°n l√† chuy√™n gia t·∫°o detailed panel description cho truy·ªán tranh.

NHI·ªÜM V·ª§: T·ª´ story outline v√† panel summary, t·∫°o PANEL DETAIL ho√†n ch·ªânh g·ªìm:
1. Detailed scene description
2. Character appearances (CHI TI·∫æT: t√≥c, m·∫Øt, khu√¥n m·∫∑t, trang ph·ª•c PH√ô H·ª¢P CONTEXT)
3. Character positions v√† actions
4. Dialogue (format: "T√™n: L·ªùi n√≥i")
5. Detailed image prompt cho Gemini AI

QUAN TR·ªåNG - M√î T·∫¢ NH√ÇN V·∫¨T CHI TI·∫æT:
- NGO·∫†I H√åNH: M√¥ t·∫£ chi ti·∫øt t√≥c (m√†u, ki·ªÉu, ƒë·ªô d√†i), m·∫Øt (m√†u, ki·ªÉu), khu√¥n m·∫∑t
- TRANG PH·ª§C: M√¥ t·∫£ THEO CONTEXT c·ªßa panel n√†y!
  + N·∫øu scene b√¨nh th∆∞·ªùng: d√πng trang ph·ª•c m·∫∑c ƒë·ªãnh
  + N·∫øu scene ƒë·∫∑c bi·ªát (ƒë√°m c∆∞·ªõi, ti·ªác, chi·∫øn ƒë·∫•u, ng·ªß...): trang ph·ª•c PH√ô H·ª¢P
  + VD: ƒê√°m c∆∞·ªõi ‚Üí vest/v√°y c∆∞·ªõi, Ng·ªß ‚Üí ƒë·ªì ng·ªß, Chi·∫øn ƒë·∫•u ‚Üí gi√°p/√°o chi·∫øn
- V≈® KH√ç/TRANG B·ªä: Ch·ªâ m√¥ t·∫£ n·∫øu nh√¢n v·∫≠t ƒëang mang theo trong scene n√†y
- ƒê·∫∂C ƒêI·ªÇM NH·∫¨N D·∫†NG: Lu√¥n gi·ªØ nh·∫•t qu√°n (s·∫πo, n·ªët ru·ªìi, h√¨nh xƒÉm...)

${styleGuide}`;

      const userPrompt = `**STORY OUTLINE**:
Title: ${outline.title}
Theme: ${outline.theme}

**CHARACTERS (th√¥ng tin c∆° b·∫£n)**:
${characterDescriptions}

**ALL PANEL SUMMARIES** (for context):
${outline.panel_summaries.map((p, i) =>
  `Panel ${p.panel_number}: ${p.summary} [${p.emotional_beat}]`
).join('\n')}

**FOCUS PANEL**: Panel ${panelSummary.panel_number}
Summary: ${panelSummary.summary}
Emotional beat: ${panelSummary.emotional_beat}
Story note: ${panelSummary.story_note}

${prevPanel ? `**Previous panel**: ${prevPanel.summary}` : '**This is the opening panel**'}
${nextPanel ? `**Next panel**: ${nextPanel.summary}` : '**This is the final panel**'}

**Y√äU C·∫¶U CHI TI·∫æT**:
1. Scene description: ƒë·ªãa ƒëi·ªÉm, th·ªùi gian, kh√¥ng kh√≠, crowd (n·∫øu c√≥)
2. Character appearances: M√î T·∫¢ CHI TI·∫æT cho T·ª™NG nh√¢n v·∫≠t xu·∫•t hi·ªán:
   - Ngo·∫°i h√¨nh: t√≥c (m√†u + ki·ªÉu + ƒë·ªô d√†i), m·∫Øt (m√†u + ki·ªÉu), khu√¥n m·∫∑t
   - Trang ph·ª•c: PH√ô H·ª¢P V·ªöI CONTEXT c·ªßa scene (xem panel summary ƒë·ªÉ x√°c ƒë·ªãnh context)
   - Trang b·ªã: v≈© kh√≠/ph·ª• ki·ªán n·∫øu mang theo trong scene n√†y
   - ƒê·∫∑c ƒëi·ªÉm nh·∫≠n d·∫°ng: s·∫πo, n·ªët ru·ªìi, h√¨nh xƒÉm... (gi·ªØ nh·∫•t qu√°n)
3. Character positions: V·ªã tr√≠ v√† h√†nh ƒë·ªông C·ª§ TH·ªÇ
4. Dialogue: Format "T√™n: L·ªùi n√≥i", ng·∫Øn g·ªçn (max 15 t·ª´), c√≥ c·∫£m x√∫c
5. Image prompt: PH·∫¢I bao g·ªìm T·∫§T C·∫¢ th√¥ng tin tr√™n + art style guide

Tr·∫£ v·ªÅ JSON:
{
  "panel_number": ${panelSummary.panel_number},
  "scene_description": "M√¥ t·∫£ chi ti·∫øt: ƒë·ªãa ƒëi·ªÉm, th·ªùi gian, kh√¥ng kh√≠, crowd/background n·∫øu c√≥",
  "character_appearances": {
    "T√™nNh√¢nV·∫≠t1": {
      "face": "Khu√¥n m·∫∑t: ki·ªÉu m·∫∑t, ƒë·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t",
      "hair": "T√≥c: m√†u + ki·ªÉu + ƒë·ªô d√†i (VD: t√≥c ƒëen d√†i qu√° vai, bu·ªôc ƒëu√¥i ng·ª±a cao)",
      "eyes": "M·∫Øt: m√†u + ki·ªÉu (VD: m·∫Øt n√¢u ƒë·∫≠m, s·∫Øc l·∫°nh)",
      "outfit": "Trang ph·ª•c PH√ô H·ª¢P CONTEXT (VD: n·∫øu ƒë√°m c∆∞·ªõi th√¨ m·∫∑c vest tr·∫Øng, n·∫øu ng·ªß th√¨ ƒë·ªì ng·ªß)",
      "equipment": "V≈© kh√≠/ph·ª• ki·ªán ƒëang mang (ho·∫∑c 'kh√¥ng c√≥' n·∫øu kh√¥ng mang)",
      "distinctive": "ƒê·∫∑c ƒëi·ªÉm nh·∫≠n d·∫°ng (s·∫πo, n·ªët ru·ªìi, h√¨nh xƒÉm...)"
    }
  },
  "character_positions": "V·ªã tr√≠ v√† action C·ª§ TH·ªÇ c·ªßa t·ª´ng nh√¢n v·∫≠t.",
  "character_expressions": "Bi·ªÉu c·∫£m khu√¥n m·∫∑t C·ª§ TH·ªÇ c·ªßa t·ª´ng nh√¢n v·∫≠t.",
  "dialogue": "Format: 'T√™n: L·ªùi n√≥i'",
  "narration": "Caption/narration box n·∫øu c·∫ßn (optional)",
  "camera_angle": "close-up/medium shot/wide shot/dutch angle/low angle/high angle/over-the-shoulder",
  "mood": "Kh√¥ng kh√≠ c·∫£m x√∫c",
  "image_prompt": "COMIC PANEL ART, ${selectedStyle.name} style, ${selectedColorMode.prompt}, ${selectedLighting.prompt}. [M√î T·∫¢ CHI TI·∫æT T·ª™NG NH√ÇN V·∫¨T: t√≥c, m·∫Øt, khu√¥n m·∫∑t, trang ph·ª•c THEO CONTEXT, ƒë·∫∑c ƒëi·ªÉm nh·∫≠n d·∫°ng]. [Character positions v√† actions]. [Facial expressions]. Setting: [scene details]. [Camera angle]. High quality manga art, speech bubbles visible (Vietnamese text ONLY), TikTok vertical 9:16."
}`;

      // In hybrid mode, use DeepSeek for panel details (fast and detailed)
      const providerForPanel = state.hybridMode ? 'deepseek' : state.textApiProvider;
      console.log(`üìù Generating detail for Panel ${panelSummary.panel_number}...`);
      console.log(`   Using: ${API_LIMITS[providerForPanel].name}${state.hybridMode ? ' (Hybrid Mode)' : ''}`);

      const data = await callTextAPI(systemPrompt, userPrompt, {
        temperature: 0.7,
        max_tokens: 2500, // Panel descriptions can be verbose with character details
        provider: providerForPanel
      });

      let content = data.choices[0].message.content;
      content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      content = content.replace(/^\uFEFF/, '');

      try {
        const parsed = JSON.parse(content);
        console.log(`‚úÖ Panel ${panelSummary.panel_number} detail generated`);
        return parsed;
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error:', parseError);
        throw new Error(`Failed to parse panel detail: ${parseError.message}`);
      }
    }


    async function generateImage(prompt, panelNum) {
      const selectedStyle = ART_STYLES.find(s => s.id === state.artStyle);
      const panelData = state.storyData?.panels[panelNum - 1];

      // Extract character descriptions for consistency
      const characterDescriptions = state.storyData?.characters?.map(char =>
        `${char.name}: ${char.visual_description}`
      ).join('\n') || '';

      // Extract dialogue for speech bubbles
      const dialogueInstruction = panelData?.dialogue
        ? `\n\nINCLUDE SPEECH BUBBLES with VIETNAMESE text: "${panelData.dialogue}". The text must be clearly readable in comic-style speech bubbles with proper typography. Use VIETNAMESE language only, NO Japanese/Korean/Chinese characters.`
        : '';

      const enhancedPrompt = `PROFESSIONAL ${selectedStyle.name.toUpperCase()} STYLE COMIC PANEL:

${prompt}

CHARACTER CONSISTENCY (maintain exact appearance across all panels):
${characterDescriptions}

TECHNICAL REQUIREMENTS:
- TikTok vertical format (9:16 aspect ratio)
- High quality professional manga/comic book art
- Vibrant, expressive colors with proper shading
- Dynamic composition with clear focal point
- Characters with detailed facial expressions showing emotions
- Clean linework and professional inking
- Proper perspective and depth${dialogueInstruction}

CRITICAL RULES:
- Keep character appearances EXACTLY as described above
- Use ONLY Vietnamese text in speech bubbles (NO Japanese/Korean/Chinese characters)
- Maintain consistent art style matching ${selectedStyle.name}
- NO foreign language text or symbols unless specifically part of background design

STYLE NOTES:
- ${selectedStyle.name} aesthetic with authentic art characteristics
- Cinematic panel layout
- Professional comic book production quality
- Emotionally engaging and visually striking`;

      console.log(`üé® Generating image for Panel ${panelNum}...`);
      console.log('üìù Enhanced prompt:', enhancedPrompt);

      const response = await fetch('/api/gemini', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          apiKey: state.geminiKey,
          prompt: enhancedPrompt
        })
      });

      const data = await response.json();

      if (!response.ok) {
        console.error(`‚ùå Gemini API Error for Panel ${panelNum}:`, data);
        throw new Error(data.error || 'Gemini API error');
      }

      console.log(`‚úÖ Successfully generated image for Panel ${panelNum}`);

      return {
        panelNum,
        imageData: data.imageData,
        prompt
      };
    }

    async function startGeneration() {
      console.log('üöÄ Starting comic generation...');
      console.log('üìä Settings:', {
        mode: state.generationMode,
        genre: state.genre,
        artStyle: state.artStyle,
        panelCount: state.panelCount,
        emotionalIntensity: state.emotionalIntensity,
        storyPrompt: state.storyPrompt
      });

      state.error = '';
      state.storyData = null;
      state.storyOutline = null;
      state.panels = [];
      state.detailedPanels = [];
      state.promptsReady = false;

      try {
        // CHECK IF SERIES MODE
        if (state.storyMode === 'series') {
          // ===== SERIES MODE FLOW =====

          // Step 1: Generate series roadmap (once only)
          if (!state.seriesOutline) {
            console.log('üì∫ Step 1: Generating series roadmap...');
            state.currentStep = 'outline';
            render();

            // Use chunked generation for hybrid mode or large series
            const useChunked = state.hybridMode || state.episodesPerSeries > getMaxSafeEpisodes();
            let roadmap;

            if (useChunked) {
              console.log('üöÄ Using CHUNKED generation (Hybrid Mode)');
              roadmap = await generateSeriesOutlineChunked((status) => {
                state.loadingMessage = status;
                render();
              });
            } else {
              console.log('üìñ Using standard generation');
              roadmap = await generateSeriesOutline();
            }

            state.seriesOutline = roadmap;
            state.loadingMessage = '';
            console.log('‚úÖ Series roadmap complete!');
            console.log(`üì∫ Episodes generated: ${roadmap.episodes?.length || 0}`);

            // Auto-save after series outline is created
            console.log('üíæ Auto-saving series outline...');
            saveCurrentStory(true);

            render();
          }

          // Step 2: Generate current episode using two-stage
          console.log(`üì∫ Generating Episode ${state.currentEpisodeIndex + 1}...`);
          state.currentStep = 'outline';
          render();

          // Generate episode outline (50 panel summaries)
          const episodeOutline = await generateEpisodeOutline(
            state.seriesOutline,
            state.currentEpisodeIndex
          );

          // Step 3: Generate detailed panels (reuse existing logic)
          console.log('üìù Stage 2: Generating panel details...');
          state.currentStep = 'panel-details';
          state.progress = { current: 0, total: episodeOutline.panel_summaries.length };
          render();

          const detailedPanels = [];
          for (let i = 0; i < episodeOutline.panel_summaries.length; i++) {
            console.log(`üìù Panel ${i + 1}/${episodeOutline.panel_summaries.length}`);
            state.progress.current = i + 1;
            render();

            try {
              const panelDetail = await generatePanelDetail(episodeOutline, i);
              detailedPanels.push(panelDetail);
              console.log(`‚úÖ Panel ${i + 1} generated`);
            } catch (err) {
              console.error(`‚ùå Panel ${i + 1} failed:`, err);
              detailedPanels.push({
                panel_number: i + 1,
                scene_description: episodeOutline.panel_summaries[i].summary,
                dialogue: '',
                image_prompt: `${episodeOutline.panel_summaries[i].summary}. Characters: ${episodeOutline.characters.map(c => c.visual_description).join(', ')}`
              });
            }

            if (i < episodeOutline.panel_summaries.length - 1) {
              await new Promise(r => setTimeout(r, 500));
            }
          }

          // Prepare storyData
          state.storyData = {
            title: `${state.seriesOutline.series_title} - Episode ${state.currentEpisodeIndex + 1}`,
            synopsis: episodeOutline.synopsis,
            theme: state.seriesOutline.theme,
            characters: state.seriesOutline.characters,
            panels: detailedPanels,
            image_prompts: detailedPanels.map(p => p.image_prompt)
          };

          console.log('‚úÖ All panel details generated');

          // STOP HERE - Wait for user approval
          state.detailedPanels = detailedPanels;
          state.promptsReady = true;
          state.currentStep = 'awaiting-approval';
          console.log('‚è∏Ô∏è  Waiting for user approval to continue with image generation...');
          render();

        } else if (state.generationMode === 'two-stage') {
          // TWO-STAGE MODE: Outline ‚Üí Panel Details ‚Üí Images

          // Stage 1: Generate story outline
          console.log('üìã Stage 1: Generating story outline...');
          state.currentStep = 'outline';
          render();

          const outline = await generateStoryOutline();
          state.storyOutline = outline;
          console.log('‚úÖ Outline generated:', outline.title);
          console.log('üë• Characters:', outline.characters?.length || 0);
          console.log('üìÑ Panel summaries:', outline.panel_summaries?.length || 0);
          render();

          // Stage 2: Generate detailed panels
          console.log('üìù Stage 2: Generating panel details...');
          state.currentStep = 'panel-details';
          state.progress = { current: 0, total: outline.panel_summaries.length };
          render();

          const detailedPanels = [];
          for (let i = 0; i < outline.panel_summaries.length; i++) {
            console.log(`\nüìù Panel ${detailedPanels.length + 1}: Generating details...`);
            state.progress.current = detailedPanels.length + 1;
            render();

            try {
              const panelDetail = await generatePanelDetail(outline, i);
              detailedPanels.push(panelDetail);
              console.log(`‚úÖ Panel ${detailedPanels.length} details generated`);
            } catch (detailErr) {
              console.error(`‚ùå Panel ${i + 1} detail generation failed:`, detailErr);
              // Use summary as fallback
              detailedPanels.push({
                panel_number: detailedPanels.length + 1,
                scene_description: outline.panel_summaries[i].summary,
                dialogue: '',
                image_prompt: `${outline.panel_summaries[i].summary}. Characters: ${outline.characters.map(c => c.visual_description).join(', ')}`
              });
            }

            // Small delay to avoid rate limiting
            if (i < outline.panel_summaries.length - 1) {
              await new Promise(r => setTimeout(r, 500));
            }
          }

          // Build storyData from outline + detailed panels
          state.storyData = {
            title: outline.title,
            synopsis: outline.synopsis,
            theme: outline.theme,
            characters: outline.characters,
            panels: detailedPanels,
            image_prompts: detailedPanels.map(p => p.image_prompt)
          };

          console.log('‚úÖ All panel details generated');

          // STOP HERE - Wait for user approval
          state.detailedPanels = detailedPanels;
          state.promptsReady = true;
          state.currentStep = 'awaiting-approval';
          console.log('‚è∏Ô∏è  Waiting for user approval to continue with image generation...');
          render();

        } else {
          // SINGLE-STAGE MODE: All-in-one story generation

          console.log('üìñ Single-stage: Generating full story...');
          state.currentStep = 'story';
          render();

          const story = await generateStory();
          state.storyData = story;
          console.log('‚úÖ Story generated successfully:', story.title);
          console.log('üë• Characters:', story.characters?.length || 0);
          console.log('üìÑ Panels:', story.panels?.length || 0);
          render();

          // Generate images
          console.log('üé® Generating images with Gemini...');
          state.currentStep = 'images';
          state.progress = { current: 0, total: story.image_prompts.length };
          render();

          const generatedPanels = [];
          for (let i = 0; i < story.image_prompts.length; i++) {
            console.log(`\nüìå Processing Panel ${i + 1}/${story.image_prompts.length}`);
            state.progress.current = i + 1;
            render();

            try {
              const panel = await generateImage(story.image_prompts[i], i + 1);
              generatedPanels.push({
                ...panel,
                panelData: story.panels[i]
              });
              console.log(`‚úÖ Panel ${i + 1} completed successfully`);
            } catch (imgErr) {
              console.error(`‚ùå Panel ${i + 1} failed:`, imgErr);
              generatedPanels.push({
                panelNum: i + 1,
                error: imgErr.message,
                panelData: story.panels[i],
                prompt: story.image_prompts[i]
              });
            }

            state.panels = [...generatedPanels];
            render();

            // Rate limit delay
            if (i < story.image_prompts.length - 1) {
              console.log('‚è≥ Waiting 2s before next panel...');
              await new Promise(r => setTimeout(r, 2000));
            }
          }

          console.log('üéâ Single-stage generation complete!');
          console.log('üìä Final stats:', {
            total: generatedPanels.length,
            successful: generatedPanels.filter(p => p.imageData).length,
            failed: generatedPanels.filter(p => p.error).length
          });
        }

        state.currentStep = 'complete';
        render();

      } catch (err) {
        console.error('üí• Generation failed:', err);
        state.error = err.message;
        state.currentStep = 'error';
        render();
      }
    }

    function openRegenerateModal(index) {
      state.showRegenerateModal = true;
      state.regeneratePanelIndex = index;
      state.regenerateModification = '';
      render();
    }

    function closeRegenerateModal() {
      state.showRegenerateModal = false;
      state.regeneratePanelIndex = null;
      state.regenerateModification = '';
      render();
    }

    async function regeneratePanel(index, modification = '') {
      if (!state.storyData) return;

      closeRegenerateModal();

      const basePrompt = state.storyData.image_prompts[index];
      const finalPrompt = modification
        ? `${basePrompt}\n\nMODIFICATION REQUEST: ${modification}`
        : basePrompt;

      state.panels[index] = {
        ...state.panels[index],
        loading: true,
        error: null,
        modification: modification || null
      };
      render();

      console.log(`üîÑ Regenerating Panel ${index + 1}...`);
      if (modification) {
        console.log('üìù Modification request:', modification);
      }

      try {
        const panel = await generateImage(finalPrompt, index + 1);
        state.panels[index] = {
          ...panel,
          panelData: state.storyData.panels[index],
          loading: false,
          modification: modification || null
        };
        console.log(`‚úÖ Panel ${index + 1} regenerated successfully`);
      } catch (err) {
        console.error(`‚ùå Panel ${index + 1} regeneration failed:`, err);
        state.panels[index] = {
          ...state.panels[index],
          error: err.message,
          loading: false
        };
      }
      render();
    }

    function addCharacter() {
      if (state.newCharName.trim() && state.newCharDesc.trim()) {
        state.characters.push({
          id: Date.now(),
          name: state.newCharName.trim(),
          description: state.newCharDesc.trim()
        });
        state.newCharName = '';
        state.newCharDesc = '';
        render();
      }
    }

    function removeCharacter(id) {
      state.characters = state.characters.filter(c => c.id !== id);
      render();
    }

    function saveApiKeys() {
      localStorage.setItem('deepseekKey', state.deepseekKey);
      localStorage.setItem('geminiKey', state.geminiKey);
      state.showApiSetup = false;
      render();
    }

    function exportPanels() {
      if (!state.storyData || state.panels.length === 0) return;
      
      const exportData = {
        story: state.storyData,
        panels: state.panels.map(p => ({
          panelNum: p.panelNum,
          prompt: p.prompt,
          hasImage: !!p.imageData,
          dialogue: p.panelData?.dialogue,
          narration: p.panelData?.narration
        })),
        exportedAt: new Date().toISOString()
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tiktok-comic-${state.storyData.title.replace(/\s+/g, '-')}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadImage(imageData, panelNum) {
      const a = document.createElement('a');
      a.href = imageData;
      a.download = `panel-${panelNum}.png`;
      a.click();
    }

    // Download all panels as ZIP file
    async function downloadAllPanels() {
      if (!state.panels || state.panels.length === 0) {
        alert('‚ö†Ô∏è Kh√¥ng c√≥ panel n√†o ƒë·ªÉ t·∫£i!');
        return;
      }

      // Filter only successful panels
      const successfulPanels = state.panels.filter(p => p.imageData);

      if (successfulPanels.length === 0) {
        alert('‚ö†Ô∏è Kh√¥ng c√≥ panel n√†o ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!');
        return;
      }

      console.log('üì¶ Creating ZIP file...');
      const zip = new JSZip();

      // Create folder name from story title (sanitize for filesystem)
      const folderName = (state.storyData?.title || 'TikTok-Comic')
        .replace(/[^a-zA-Z0-9\u00C0-\u1EF9\s-]/g, '') // Remove special chars, keep Vietnamese
        .replace(/\s+/g, '-') // Replace spaces with dash
        .substring(0, 50); // Limit length

      const folder = zip.folder(folderName);

      // Add story info text file
      if (state.storyData) {
        let storyInfo = `Title: ${state.storyData.title}\n`;
        storyInfo += `Synopsis: ${state.storyData.synopsis}\n`;
        storyInfo += `Theme: ${state.storyData.theme}\n`;
        storyInfo += `\nCharacters:\n`;
        state.storyData.characters?.forEach((char, i) => {
          storyInfo += `${i + 1}. ${char.name} (${char.role}): ${char.personality}\n`;
        });
        storyInfo += `\nTotal Panels: ${successfulPanels.length}\n`;
        storyInfo += `Generated: ${new Date().toLocaleString('vi-VN')}\n`;

        folder.file('story-info.txt', storyInfo);
      }

      // Add each panel image
      for (let i = 0; i < successfulPanels.length; i++) {
        const panel = successfulPanels[i];

        // Convert base64 to blob
        const base64Data = panel.imageData.split(',')[1];
        const binaryData = atob(base64Data);
        const arrayBuffer = new Uint8Array(binaryData.length);
        for (let j = 0; j < binaryData.length; j++) {
          arrayBuffer[j] = binaryData.charCodeAt(j);
        }

        // Add to ZIP with panel number (padded with zeros)
        const panelNumber = String(panel.panelNum).padStart(3, '0');
        const filename = `panel-${panelNumber}.png`;
        folder.file(filename, arrayBuffer, { binary: true });

        console.log(`‚úÖ Added ${filename} to ZIP`);
      }

      // Generate ZIP file
      console.log('üîÑ Generating ZIP file...');
      try {
        const content = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        // Download ZIP
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${folderName}.zip`;
        a.click();
        URL.revokeObjectURL(url);

        console.log('‚úÖ ZIP file downloaded successfully!');
        alert(`‚úÖ ƒê√£ t·∫£i ${successfulPanels.length} panels v√†o file "${folderName}.zip"`);
      } catch (error) {
        console.error('‚ùå Error creating ZIP:', error);
        alert('‚ùå L·ªói khi t·∫°o file ZIP. Vui l√≤ng th·ª≠ l·∫°i.');
      }
    }

    // Helper: Strip character name from dialogue
    // Converts "T√™n: L·ªùi n√≥i" -> "L·ªùi n√≥i"
    function stripCharacterName(dialogue) {
      if (!dialogue) return '';
      // Match pattern "Name: Text" and extract only the text
      const match = dialogue.match(/^[^:]+:\s*(.+)$/);
      return match ? match[1] : dialogue;
    }

    // Render regenerate modal
    function renderRegenerateModal() {
      const modal = document.getElementById('regenerateModal');
      if (!state.showRegenerateModal || state.regeneratePanelIndex === null) {
        modal.innerHTML = '';
        return;
      }

      const panelNum = state.regeneratePanelIndex + 1;
      const panel = state.panels[state.regeneratePanelIndex];

      modal.innerHTML = `
        <div class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <div class="glass rounded-3xl p-8 max-w-2xl w-full shadow-2xl">
            <h2 class="text-2xl font-bold text-white mb-2 flex items-center gap-3">
              <span class="text-3xl">üîÑ</span> T·∫°o l·∫°i Panel ${panelNum}
            </h2>
            <p class="text-slate-400 mb-6 text-sm">
              B·∫°n c√≥ th·ªÉ t·∫°o l·∫°i ·∫£nh y nguy√™n ho·∫∑c th√™m y√™u c·∫ßu s·ª≠a ƒë·ªïi c·ª• th·ªÉ
            </p>

            ${panel?.modification ? `
              <div class="mb-4 p-3 bg-blue-500/20 border border-blue-500/50 rounded-lg">
                <p class="text-xs text-blue-300 mb-1 font-semibold">L·∫ßn s·ª≠a tr∆∞·ªõc:</p>
                <p class="text-sm text-blue-200">${panel.modification}</p>
              </div>
            ` : ''}

            <div class="mb-6">
              <label class="block text-sm font-medium text-slate-300 mb-2">
                Y√™u c·∫ßu s·ª≠a ƒë·ªïi (t√πy ch·ªçn)
              </label>
              <textarea
                id="modificationInput"
                placeholder="VD: L√†m t√≥c d√†i h∆°n, ƒë·ªïi m√†u √°o th√†nh ƒë·ªè, th√™m chi ti·∫øt background n√∫i non, l√†m khu√¥n m·∫∑t vui v·∫ª h∆°n, th√™m ng∆∞·ªùi ·ªü ph√≠a sau, v.v."
                rows="4"
                class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
                oninput="state.regenerateModification = this.value"
              >${state.regenerateModification}</textarea>
              <p class="text-xs text-slate-500 mt-2">
                üí° ƒê·ªÉ tr·ªëng n·∫øu mu·ªën t·∫°o l·∫°i y nguy√™n. AI s·∫Ω c·ªë g·∫Øng gi·ªØ nguy√™n story nh∆∞ng v·∫Ω l·∫°i v·ªõi style kh√°c.
              </p>
            </div>

            <div class="flex gap-3">
              <button
                onclick="closeRegenerateModal()"
                class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-medium transition-colors"
              >
                ‚ùå H·ªßy
              </button>
              <button
                onclick="regeneratePanel(${state.regeneratePanelIndex}, '')"
                class="flex-1 py-3 bg-slate-600 hover:bg-slate-500 rounded-xl text-white font-medium transition-colors"
              >
                üîÑ T·∫°o l·∫°i y nguy√™n
              </button>
              <button
                onclick="regeneratePanel(${state.regeneratePanelIndex}, state.regenerateModification)"
                class="flex-1 py-3 gradient-btn rounded-xl text-white font-bold transition-all transform hover:scale-[1.02]"
              >
                ‚ú® T·∫°o l·∫°i v·ªõi s·ª≠a ƒë·ªïi
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // Render Story Library Modal
    function renderStoryLibraryModal() {
      const modal = document.getElementById('storyLibraryModal');
      if (!state.showStoryLibrary) {
        modal.innerHTML = '';
        return;
      }

      const formatDate = (ts) => new Date(ts).toLocaleDateString('vi-VN', {
        day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
      });

      modal.innerHTML = `
        <div class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <div class="glass rounded-3xl p-6 max-w-4xl w-full max-h-[85vh] shadow-2xl flex flex-col">
            <div class="flex items-center justify-between mb-4">
              <h2 class="text-2xl font-bold text-white flex items-center gap-3">
                <span class="text-3xl">üìö</span> Th∆∞ vi·ªán Truy·ªán
              </h2>
              <div class="flex gap-2">
                <button
                  onclick="createNewStory()"
                  class="px-4 py-2 bg-green-500 hover:bg-green-600 rounded-xl text-white font-medium transition-colors flex items-center gap-2"
                >
                  <span>‚ûï</span> Truy·ªán m·ªõi
                </button>
                <button
                  onclick="state.showStoryLibrary = false; render();"
                  class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-medium transition-colors"
                >
                  ‚úï ƒê√≥ng
                </button>
              </div>
            </div>

            ${state.currentStoryId ? `
              <div class="mb-4 p-3 bg-blue-500/20 border border-blue-500/50 rounded-lg">
                <p class="text-sm text-blue-300">
                  <span class="font-bold">üìñ ƒêang m·ªü:</span> ${state.savedStories.find(s => s.id === state.currentStoryId)?.name || 'Unknown'}
                </p>
              </div>
            ` : ''}

            <div class="flex-1 overflow-y-auto">
              ${state.savedStories.length === 0 ? `
                <div class="text-center py-12">
                  <span class="text-6xl mb-4 block">üì≠</span>
                  <p class="text-slate-400 text-lg">Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c l∆∞u</p>
                  <p class="text-slate-500 text-sm mt-2">T·∫°o truy·ªán m·ªõi v√† nh·∫•n "L∆∞u" ƒë·ªÉ b·∫Øt ƒë·∫ßu!</p>
                </div>
              ` : `
                <div class="grid gap-3">
                  ${state.savedStories.map(story => `
                    <div class="p-4 bg-slate-800/50 rounded-xl border ${
                      story.id === state.currentStoryId ? 'border-blue-500' : 'border-slate-700'
                    } hover:border-slate-500 transition-colors">
                      <div class="flex items-start justify-between gap-4">
                        <div class="flex-1 min-w-0">
                          <h3 class="text-white font-bold text-lg truncate">${story.name}</h3>
                          <div class="flex flex-wrap gap-2 mt-2">
                            <span class="px-2 py-0.5 bg-purple-500/20 text-purple-300 rounded text-xs">
                              ${story.storyMode === 'series' ? 'üì∫ Series' : 'üìñ Single'}
                            </span>
                            <span class="px-2 py-0.5 bg-pink-500/20 text-pink-300 rounded text-xs">
                              ${story.genre || 'N/A'}
                            </span>
                            ${story.seriesOutline?.characters?.length ? `
                              <span class="px-2 py-0.5 bg-cyan-500/20 text-cyan-300 rounded text-xs">
                                üë• ${story.seriesOutline.characters.length} nh√¢n v·∫≠t
                              </span>
                            ` : ''}
                            ${story.episodes?.length ? `
                              <span class="px-2 py-0.5 bg-green-500/20 text-green-300 rounded text-xs">
                                üìñ ${story.episodes.length}/${story.episodesPerSeries || '?'} chap
                              </span>
                            ` : ''}
                          </div>
                          <p class="text-xs text-slate-500 mt-2">
                            C·∫≠p nh·∫≠t: ${formatDate(story.updatedAt)}
                          </p>
                        </div>
                        <div class="flex gap-2 flex-shrink-0">
                          <button
                            onclick="loadStory('${story.id}')"
                            class="px-3 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg text-white text-sm font-medium transition-colors"
                          >
                            üìÇ M·ªü
                          </button>
                          <button
                            onclick="state.adGeneratorStoryId = '${story.id}'; state.activeTab = 'ads'; state.showStoryLibrary = false; render();"
                            class="px-3 py-2 bg-yellow-500 hover:bg-yellow-600 rounded-lg text-white text-sm font-medium transition-colors"
                            title="T·∫°o panel qu·∫£ng c√°o"
                          >
                            üì¢
                          </button>
                          <button
                            onclick="deleteStory('${story.id}')"
                            class="px-3 py-2 bg-red-500/20 hover:bg-red-500/40 rounded-lg text-red-300 text-sm font-medium transition-colors"
                          >
                            üóëÔ∏è
                          </button>
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    // Render Ad Generator Tab (Full page)
    function renderAdGeneratorTab() {
      const storyId = state.adGeneratorStoryId;
      const selectedStory = storyId ? state.savedStories.find(s => s.id === storyId) : null;
      const characters = selectedStory?.seriesOutline?.characters || [];
      const artStyle = selectedStory ? ART_STYLES.find(s => s.id === selectedStory.artStyle) : null;
      const colorMode = selectedStory ? COLOR_MODES.find(c => c.id === selectedStory.colorMode) : null;
      const lightingStyle = selectedStory ? LIGHTING_STYLES.find(l => l.id === selectedStory.lightingStyle) : null;

      return `
        <div class="grid lg:grid-cols-3 gap-8">
          <!-- Left Panel: Story Selection & Product Info -->
          <div class="lg:col-span-1 space-y-6">
            <!-- Story Selection -->
            <div class="glass rounded-2xl p-6">
              <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                <span>üìö</span> Ch·ªçn Truy·ªán
              </h3>

              ${state.savedStories.length === 0 ? `
                <div class="p-4 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-center">
                  <p class="text-yellow-300 text-sm">‚ö†Ô∏è Ch∆∞a c√≥ truy·ªán n√†o ƒë∆∞·ª£c l∆∞u!</p>
                  <p class="text-slate-400 text-xs mt-2">H√£y t·∫°o v√† l∆∞u truy·ªán tr∆∞·ªõc ƒë·ªÉ d√πng nh√¢n v·∫≠t cho qu·∫£ng c√°o.</p>
                  <button
                    onclick="state.activeTab = 'story'; render();"
                    class="mt-3 px-4 py-2 bg-purple-500 hover:bg-purple-600 rounded-lg text-white text-sm font-medium transition-colors"
                  >
                    üìñ T·∫°o Truy·ªán M·ªõi
                  </button>
                </div>
              ` : `
                <select
                  onchange="state.adGeneratorStoryId = this.value || null; render();"
                  class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
                >
                  <option value="">-- Ch·ªçn truy·ªán --</option>
                  ${state.savedStories.map(story => `
                    <option value="${story.id}" ${story.id === storyId ? 'selected' : ''}>
                      ${story.name} (${story.seriesOutline?.characters?.length || 0} nh√¢n v·∫≠t)
                    </option>
                  `).join('')}
                </select>
              `}

              ${selectedStory ? `
                <div class="mt-4 p-3 bg-gradient-to-r from-yellow-500/10 to-orange-500/10 border border-yellow-500/30 rounded-xl">
                  <p class="text-sm text-yellow-300 font-medium">
                    üìñ ${selectedStory.name}
                  </p>
                  <p class="text-xs text-slate-400 mt-1">
                    Style: ${artStyle?.name || 'N/A'} ‚Ä¢ ${colorMode?.name || 'N/A'} ‚Ä¢ ${lightingStyle?.name || 'N/A'}
                  </p>
                </div>
              ` : ''}
            </div>

            <!-- Characters Preview -->
            ${selectedStory ? `
              <div class="glass rounded-2xl p-6">
                <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                  <span>üë•</span> Nh√¢n v·∫≠t (${characters.length})
                </h3>
                <div class="space-y-2 max-h-60 overflow-y-auto">
                  ${characters.map(char => `
                    <div class="p-3 bg-slate-800/50 rounded-lg border border-slate-700">
                      <div class="flex items-center gap-2">
                        <span class="w-8 h-8 rounded-full bg-gradient-to-r from-cyan-500 to-blue-500 flex items-center justify-center text-white text-sm font-bold">
                          ${char.name.charAt(0)}
                        </span>
                        <div>
                          <p class="text-white font-medium text-sm">${char.name}</p>
                          <p class="text-slate-400 text-xs">${char.role}</p>
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}

            <!-- Product Info - Simplified -->
            <div class="glass rounded-2xl p-6">
              <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                <span>üè∑Ô∏è</span> Th√¥ng tin s·∫£n ph·∫©m
              </h3>

              <div class="space-y-4">
                <!-- Product Name -->
                <div>
                  <label class="block text-sm font-medium text-slate-300 mb-2">
                    T√™n s·∫£n ph·∫©m <span class="text-pink-400">*</span>
                  </label>
                  <input
                    type="text"
                    id="adProductName"
                    placeholder="VD: Coca-Cola, iPhone 15, B√°nh Oreo..."
                    value="${state.adProduct.name || ''}"
                    oninput="state.adProduct.name = this.value; updateAdGenerateButton();"
                    class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-yellow-500"
                  />
                </div>

                <!-- Product Image Upload -->
                <div>
                  <label class="block text-sm font-medium text-slate-300 mb-2">
                    ·∫¢nh s·∫£n ph·∫©m <span class="text-pink-400">*</span>
                  </label>
                  <div class="border-2 border-dashed border-slate-600 rounded-xl p-4 hover:border-yellow-500/50 transition-colors">
                    ${state.adProduct.image ? `
                      <div class="relative">
                        <img
                          src="${state.adProduct.image}"
                          alt="Product"
                          class="w-full h-40 object-contain rounded-lg bg-slate-800"
                        />
                        <button
                          onclick="state.adProduct.image = null; render();"
                          class="absolute top-2 right-2 w-6 h-6 bg-red-500 hover:bg-red-600 rounded-full flex items-center justify-center text-white text-xs transition-colors"
                        >‚úï</button>
                      </div>
                    ` : `
                      <label class="cursor-pointer flex flex-col items-center gap-3 py-4">
                        <div class="w-16 h-16 rounded-full bg-gradient-to-r from-yellow-500/20 to-orange-500/20 flex items-center justify-center text-3xl border-2 border-yellow-500/30">
                          üì∑
                        </div>
                        <div class="text-center">
                          <span class="text-sm text-slate-300 font-medium">Click ƒë·ªÉ t·∫£i ·∫£nh s·∫£n ph·∫©m</span>
                          <p class="text-xs text-slate-500 mt-1">JPG, PNG, WebP (max 5MB)</p>
                        </div>
                        <input
                          type="file"
                          accept="image/*"
                          class="hidden"
                          onchange="handleAdProductImageUpload(event)"
                        />
                      </label>
                    `}
                  </div>
                </div>

                <!-- AI Auto Info -->
                <div class="p-3 bg-gradient-to-r from-purple-500/10 to-cyan-500/10 border border-purple-500/30 rounded-xl">
                  <p class="text-xs text-purple-300 flex items-start gap-2">
                    <span class="text-lg">ü§ñ</span>
                    <span>
                      <strong>AI t·ª± ƒë·ªông:</strong> DeepSeek s·∫Ω ph√¢n t√≠ch s·∫£n ph·∫©m, ch·ªçn nh√¢n v·∫≠t ph√π h·ª£p nh·∫•t t·ª´ truy·ªán,
                      t·∫°o b·ªëi c·∫£nh v√† c√¢u tho·∫°i qu·∫£ng c√°o t·ª± nhi√™n.
                    </span>
                  </p>
                </div>

                <!-- Generate Button -->
                <button
                  id="adGenerateBtn"
                  onclick="generateAdPanel()"
                  ${!selectedStory || characters.length === 0 || !state.adProduct.name || !state.adProduct.image || state.adGenerating ? 'disabled' : ''}
                  class="w-full py-4 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 rounded-xl font-bold text-white text-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-3"
                >
                  ${state.adGenerating ? `
                    <svg class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    ƒêang t·∫°o...
                  ` : 'üé® T·∫°o Panel Qu·∫£ng C√°o'}
                </button>

                <p id="adWarning" class="${!selectedStory || !state.adProduct.name || !state.adProduct.image ? 'text-xs text-yellow-300 text-center' : 'text-xs text-green-300 text-center'}">
                  ${!selectedStory
                    ? '‚ö†Ô∏è Ch·ªçn truy·ªán tr∆∞·ªõc ƒë·ªÉ d√πng nh√¢n v·∫≠t'
                    : !state.adProduct.name
                    ? '‚ö†Ô∏è Nh·∫≠p t√™n s·∫£n ph·∫©m'
                    : !state.adProduct.image
                    ? '‚ö†Ô∏è T·∫£i ·∫£nh s·∫£n ph·∫©m l√™n'
                    : '‚úÖ S·∫µn s√†ng t·∫°o panel qu·∫£ng c√°o!'}
                </p>
              </div>
            </div>
          </div>

          <!-- Right Panel: Generated Ads -->
          <div class="lg:col-span-2">
            <div class="glass rounded-2xl p-6">
              <div class="flex items-center justify-between mb-6">
                <h3 class="text-lg font-bold text-white flex items-center gap-2">
                  <span>üñºÔ∏è</span> Panel Qu·∫£ng C√°o ƒê√£ T·∫°o (${state.generatedAdPanels.length})
                </h3>
                ${state.generatedAdPanels.length > 0 ? `
                  <button
                    onclick="state.generatedAdPanels = []; render();"
                    class="px-3 py-1 bg-red-500/20 hover:bg-red-500/40 rounded-lg text-red-300 text-sm font-medium transition-colors"
                  >
                    üóëÔ∏è X√≥a t·∫•t c·∫£
                  </button>
                ` : ''}
              </div>

              ${state.generatedAdPanels.length === 0 ? `
                <div class="text-center py-16">
                  <div class="text-6xl mb-4">üì¢</div>
                  <p class="text-slate-400 text-lg">Ch∆∞a c√≥ panel qu·∫£ng c√°o n√†o</p>
                  <p class="text-slate-500 text-sm mt-2">
                    Ch·ªçn truy·ªán, nh·∫≠p th√¥ng tin s·∫£n ph·∫©m v√† b·∫•m "T·∫°o Panel Qu·∫£ng C√°o"
                  </p>
                </div>
              ` : `
                <div class="grid md:grid-cols-2 gap-6">
                  ${state.generatedAdPanels.map((panel, index) => `
                    <div class="relative group rounded-xl overflow-hidden border-2 border-slate-700 hover:border-yellow-500/50 transition-colors">
                      <img
                        src="${panel.imageUrl}"
                        alt="Ad Panel ${index + 1}"
                        class="w-full aspect-[9/16] object-cover"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/90 via-black/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity">
                        <div class="absolute bottom-0 left-0 right-0 p-4">
                          <!-- Product Info -->
                          <div class="flex items-center gap-2 mb-2">
                            ${panel.productImage ? `
                              <img
                                src="${panel.productImage}"
                                alt="Product"
                                class="w-10 h-10 rounded-lg object-cover border border-white/30"
                              />
                            ` : ''}
                            <div>
                              <p class="text-white font-bold text-sm">${panel.productName}</p>
                              <p class="text-slate-300 text-xs">${panel.storyName || ''}</p>
                            </div>
                          </div>

                          <!-- Selected Characters -->
                          ${panel.selectedCharacters ? `
                            <div class="mb-2 flex flex-wrap gap-1">
                              ${panel.selectedCharacters.map(char => `
                                <span class="px-2 py-0.5 bg-purple-500/30 border border-purple-500/50 rounded-full text-purple-200 text-xs">
                                  üë§ ${char}
                                </span>
                              `).join('')}
                            </div>
                          ` : ''}

                          <!-- Slogan -->
                          <p class="text-yellow-300 text-sm font-medium mb-1">"${panel.adData?.ad_slogan || panel.adData?.ad_text || ''}"</p>

                          <!-- Dialogue -->
                          ${panel.adData?.dialogue ? `
                            <p class="text-slate-300 text-xs mb-2 italic">"${panel.adData.dialogue}"</p>
                          ` : ''}

                          <!-- Actions -->
                          <div class="flex gap-2">
                            <button
                              onclick="downloadAdPanel(${index})"
                              class="flex-1 px-3 py-2 bg-green-500 hover:bg-green-600 rounded-lg text-white text-xs font-medium transition-colors"
                            >
                              üíæ T·∫£i v·ªÅ
                            </button>
                            <button
                              onclick="openAdRegenerateModal(${index})"
                              class="px-3 py-2 bg-yellow-500/50 hover:bg-yellow-500 rounded-lg text-white text-xs font-medium transition-colors"
                              title="S·ª≠a / T·∫°o l·∫°i panel"
                            >
                              üîÑ
                            </button>
                            <button
                              onclick="state.generatedAdPanels.splice(${index}, 1); render();"
                              class="px-3 py-2 bg-red-500/50 hover:bg-red-500 rounded-lg text-white text-xs font-medium transition-colors"
                            >
                              üóëÔ∏è
                            </button>
                          </div>
                        </div>
                      </div>

                      <!-- Badge -->
                      <div class="absolute top-2 left-2 px-2 py-1 bg-yellow-500 rounded-full text-xs font-bold text-black">
                        #${index + 1}
                      </div>

                      <!-- Product thumbnail -->
                      ${panel.productImage ? `
                        <div class="absolute top-2 right-2 w-10 h-10 rounded-lg overflow-hidden border-2 border-white/50 shadow-lg">
                          <img src="${panel.productImage}" alt="Product" class="w-full h-full object-cover" />
                        </div>
                      ` : ''}
                    </div>
                  `).join('')}
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    // Download Ad Panel
    function downloadAdPanel(index) {
      const panel = state.generatedAdPanels[index];
      if (!panel) return;

      const a = document.createElement('a');
      a.href = panel.imageUrl;
      a.download = 'ad-panel-' + panel.productName.replace(/\s+/g, '-') + '-' + (index + 1) + '.png';
      a.click();
    }

    // ===========================================
    // AD PANEL REGENERATION
    // ===========================================

    function openAdRegenerateModal(index) {
      state.showAdRegenerateModal = true;
      state.regenerateAdPanelIndex = index;
      state.adRegenerateModification = '';
      render();
    }

    function closeAdRegenerateModal() {
      state.showAdRegenerateModal = false;
      state.regenerateAdPanelIndex = null;
      state.adRegenerateModification = '';
      render();
    }

    async function regenerateAdPanel(index, modification = '') {
      const panel = state.generatedAdPanels[index];
      if (!panel) return;

      closeAdRegenerateModal();

      // Set loading state
      state.adGenerating = true;
      state.loadingMessage = modification
        ? 'ƒêang t·∫°o l·∫°i panel v·ªõi y√™u c·∫ßu s·ª≠a ƒë·ªïi...'
        : 'ƒêang t·∫°o l·∫°i panel qu·∫£ng c√°o...';
      render();

      console.log(`üîÑ Regenerating Ad Panel ${index + 1}...`);
      if (modification) {
        console.log('üìù Modification request:', modification);
      }

      try {
        // Get story info for art style
        const story = state.savedStories.find(s => s.id === panel.storyId);
        const artStyle = ART_STYLES.find(s => s.id === story?.artStyle);
        const colorMode = COLOR_MODES.find(c => c.id === story?.colorMode);
        const lightingStyle = LIGHTING_STYLES.find(l => l.id === story?.lightingStyle);

        // Build regeneration prompt based on original ad data
        let finalImagePrompt = `Create an advertisement comic panel.

CHARACTERS: ${panel.selectedCharacters?.join(', ') || 'character from the story'}
ACTION: ${panel.adData?.character_action || 'using the product'}
SCENE: ${panel.adData?.scene_description || 'advertising scene'}
MOOD: ${panel.adData?.mood || 'positive, engaging'}
DIALOGUE: "${panel.adData?.dialogue || ''}"
SLOGAN: "${panel.adData?.ad_slogan || ''}"

‚ö†Ô∏è PRODUCT PLACEMENT RULES:
The attached image shows the product "${panel.productName}" that MUST appear in this comic panel.
- The product should ONLY appear in the character's HANDS or being USED by the character
- Draw the product to look EXACTLY like the reference image (same shape, colors, logo, packaging)
- The product must be clearly visible and recognizable
- DO NOT add extra product images in corners, borders, or floating in the scene
- DO NOT duplicate the product - show it ONCE, naturally held/used by the character

${panel.adData?.image_prompt || ''}

${artStyle ? `ART STYLE: ${artStyle.name}, ${colorMode?.name || ''}, ${lightingStyle?.name || ''}` : ''}

IMPORTANT: The product appears ONLY where the character is holding/using it - nowhere else in the image. Include speech bubbles with Vietnamese dialogue.`;

        // Add modification if provided
        if (modification) {
          finalImagePrompt += `\n\nüîß MODIFICATION REQUEST: ${modification}`;
        }

        console.log('üì¢ Regenerating ad image with prompt:', finalImagePrompt);

        const imageResponse = await fetch('/api/gemini', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: finalImagePrompt,
            apiKey: state.geminiKey,
            referenceImage: panel.productImage
          })
        });

        const imageResult = await imageResponse.json();

        if (imageResult.imageData) {
          // Update the panel with new image
          state.generatedAdPanels[index] = {
            ...panel,
            imageUrl: imageResult.imageData,
            modification: modification || null,
            regeneratedAt: Date.now()
          };
          console.log(`‚úÖ Ad Panel ${index + 1} regenerated successfully`);
        } else {
          throw new Error(imageResult.error || 'Failed to regenerate ad image');
        }

        state.adGenerating = false;
        state.loadingMessage = '';
        render();

      } catch (error) {
        console.error(`‚ùå Ad Panel ${index + 1} regeneration failed:`, error);
        alert('L·ªói t·∫°o l·∫°i panel: ' + error.message);
        state.adGenerating = false;
        state.loadingMessage = '';
        render();
      }
    }

    // Render Ad Regenerate Modal
    function renderAdRegenerateModal() {
      const modal = document.getElementById('adRegenerateModal');
      if (!modal) return;

      if (!state.showAdRegenerateModal || state.regenerateAdPanelIndex === null) {
        modal.innerHTML = '';
        return;
      }

      const panelNum = state.regenerateAdPanelIndex + 1;
      const panel = state.generatedAdPanels[state.regenerateAdPanelIndex];

      modal.innerHTML = `
        <div class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <div class="glass rounded-3xl p-8 max-w-2xl w-full shadow-2xl">
            <h2 class="text-2xl font-bold text-white mb-2 flex items-center gap-3">
              <span class="text-3xl">üîÑ</span> T·∫°o l·∫°i Panel QC #${panelNum}
            </h2>
            <p class="text-slate-400 mb-4 text-sm">
              S·∫£n ph·∫©m: <span class="text-yellow-300 font-medium">${panel?.productName || ''}</span>
            </p>

            ${panel?.modification ? `
              <div class="mb-4 p-3 bg-blue-500/20 border border-blue-500/50 rounded-lg">
                <p class="text-xs text-blue-300 mb-1 font-semibold">L·∫ßn s·ª≠a tr∆∞·ªõc:</p>
                <p class="text-sm text-blue-200">${panel.modification}</p>
              </div>
            ` : ''}

            <!-- Current panel preview -->
            <div class="mb-4 flex gap-4">
              <div class="w-32 aspect-[9/16] rounded-lg overflow-hidden border border-slate-600">
                <img src="${panel?.imageUrl || ''}" alt="Current panel" class="w-full h-full object-cover" />
              </div>
              <div class="flex-1">
                <p class="text-xs text-slate-400 mb-2">Th√¥ng tin panel hi·ªán t·∫°i:</p>
                <p class="text-sm text-slate-300 mb-1">üìç ${panel?.adData?.scene_description || 'N/A'}</p>
                <p class="text-sm text-yellow-300 mb-1">üí¨ "${panel?.adData?.ad_slogan || ''}"</p>
                ${panel?.adData?.dialogue ? `<p class="text-sm text-slate-400 italic">"${panel.adData.dialogue}"</p>` : ''}
              </div>
            </div>

            <div class="mb-6">
              <label class="block text-sm font-medium text-slate-300 mb-2">
                Y√™u c·∫ßu s·ª≠a ƒë·ªïi (t√πy ch·ªçn)
              </label>
              <textarea
                id="adModificationInput"
                placeholder="VD: ƒê·ªïi g√≥c ch·ª•p, l√†m s·∫£n ph·∫©m n·ªïi b·∫≠t h∆°n, thay ƒë·ªïi bi·ªÉu c·∫£m nh√¢n v·∫≠t, th√™m hi·ªáu ·ª©ng √°nh s√°ng, v.v."
                rows="4"
                class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 resize-none"
                oninput="state.adRegenerateModification = this.value"
              >${state.adRegenerateModification}</textarea>
              <p class="text-xs text-slate-500 mt-2">
                üí° ƒê·ªÉ tr·ªëng n·∫øu mu·ªën t·∫°o l·∫°i v·ªõi c√πng y√™u c·∫ßu nh∆∞ng style kh√°c.
              </p>
            </div>

            <div class="flex gap-3">
              <button
                onclick="closeAdRegenerateModal()"
                class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl text-white font-medium transition-colors"
              >
                ‚ùå H·ªßy
              </button>
              <button
                onclick="regenerateAdPanel(${state.regenerateAdPanelIndex}, '')"
                class="flex-1 py-3 bg-slate-600 hover:bg-slate-500 rounded-xl text-white font-medium transition-colors"
              >
                üîÑ T·∫°o l·∫°i y nguy√™n
              </button>
              <button
                onclick="regenerateAdPanel(${state.regenerateAdPanelIndex}, state.adRegenerateModification)"
                class="flex-1 py-3 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-400 hover:to-orange-400 rounded-xl text-white font-bold transition-all transform hover:scale-[1.02]"
              >
                ‚ú® T·∫°o l·∫°i v·ªõi s·ª≠a ƒë·ªïi
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // Handle product image upload for ad generator
    function handleAdProductImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check file size (max 5MB)
      if (file.size > 5 * 1024 * 1024) {
        alert('·∫¢nh qu√° l·ªõn! Vui l√≤ng ch·ªçn ·∫£nh d∆∞·ªõi 5MB.');
        return;
      }

      // Check file type
      if (!file.type.startsWith('image/')) {
        alert('Vui l√≤ng ch·ªçn file ·∫£nh (JPG, PNG, WebP)!');
        return;
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        state.adProduct.image = e.target.result;
        render();
      };
      reader.readAsDataURL(file);
    }

    // Update ad generate button without full re-render (to prevent scroll jump)
    function updateAdGenerateButton() {
      const btn = document.getElementById('adGenerateBtn');
      const warning = document.getElementById('adWarning');
      if (!btn) return;

      const storyId = state.adGeneratorStoryId;
      const story = storyId ? state.savedStories.find(s => s.id === storyId) : null;
      const characters = story?.seriesOutline?.characters || [];
      const hasName = state.adProduct.name && state.adProduct.name.trim().length > 0;
      const hasImage = !!state.adProduct.image;
      const canGenerate = story && characters.length > 0 && hasName && hasImage && !state.adGenerating;

      btn.disabled = !canGenerate;

      // Update warning text
      if (warning) {
        if (!story) {
          warning.innerHTML = '‚ö†Ô∏è Ch·ªçn truy·ªán tr∆∞·ªõc ƒë·ªÉ d√πng nh√¢n v·∫≠t';
          warning.className = 'text-xs text-yellow-300 text-center';
        } else if (!hasName) {
          warning.innerHTML = '‚ö†Ô∏è Nh·∫≠p t√™n s·∫£n ph·∫©m';
          warning.className = 'text-xs text-yellow-300 text-center';
        } else if (!hasImage) {
          warning.innerHTML = '‚ö†Ô∏è T·∫£i ·∫£nh s·∫£n ph·∫©m l√™n';
          warning.className = 'text-xs text-yellow-300 text-center';
        } else {
          warning.innerHTML = '‚úÖ S·∫µn s√†ng t·∫°o panel qu·∫£ng c√°o!';
          warning.className = 'text-xs text-green-300 text-center';
        }
      }
    }

    // Generate Ad Panel - AI Auto-selects everything
    async function generateAdPanel() {
      const storyId = state.adGeneratorStoryId;
      const story = storyId ? state.savedStories.find(s => s.id === storyId) : null;
      const characters = story?.seriesOutline?.characters || [];

      if (!story || characters.length === 0) {
        alert('Vui l√≤ng ch·ªçn truy·ªán c√≥ nh√¢n v·∫≠t!');
        return;
      }

      if (!state.adProduct.name) {
        alert('Vui l√≤ng nh·∫≠p t√™n s·∫£n ph·∫©m!');
        return;
      }

      if (!state.adProduct.image) {
        alert('Vui l√≤ng t·∫£i ·∫£nh s·∫£n ph·∫©m l√™n!');
        return;
      }

      // Get art style from story
      const artStyle = ART_STYLES.find(s => s.id === story.artStyle);
      const colorMode = COLOR_MODES.find(c => c.id === story.colorMode);
      const lightingStyle = LIGHTING_STYLES.find(l => l.id === story.lightingStyle);

      // Build detailed character info for DeepSeek to choose from
      const charInfo = characters.map((char, idx) => `
${idx + 1}. ${char.name} (${char.role})
   - Ngo·∫°i h√¨nh: ${char.visual_description}
   - T√≠nh c√°ch: ${char.personality || 'N/A'}
   - Vai tr√≤: ${char.role}`).join('\n');

      state.adGenerating = true;
      state.loadingMessage = 'AI ƒëang ph√¢n t√≠ch v√† t·∫°o √Ω t∆∞·ªüng qu·∫£ng c√°o...';
      render();

      try {
        // DeepSeek auto-creates everything
        const systemPrompt = `B·∫°n l√† chuy√™n gia marketing v√† s√°ng t·∫°o qu·∫£ng c√°o truy·ªán tranh.

NHI·ªÜM V·ª§: T·∫°o m·ªôt panel qu·∫£ng c√°o HI·ªÜU QU·∫¢ cho s·∫£n ph·∫©m "${state.adProduct.name}" s·ª≠ d·ª•ng nh√¢n v·∫≠t t·ª´ truy·ªán.

∆ØU TI√äN QUAN TR·ªåNG (theo th·ª© t·ª±):
1. B·ªêI C·∫¢NH H·ª¢P L√ù - T·∫°o scene ph√π h·ª£p ƒë·ªÉ qu·∫£ng c√°o s·∫£n ph·∫©m (VD: n∆∞·ªõc gi·∫£i kh√°t ‚Üí tr·ªùi n√≥ng, ngh·ªâ ng∆°i, th·ªÉ thao...)
2. CH·ªåN 1-2 nh√¢n v·∫≠t B·∫§T K·ª≤ - Kh√¥ng c·∫ßn ƒë√∫ng t√≠nh c√°ch, ch·ªâ c·∫ßn ngo·∫°i h√¨nh ƒë·∫πp v√† ph√π h·ª£p visual
3. T·∫†O c√¢u tho·∫°i/slogan HAY v√† B√ÅN H√ÄNG
4. T·∫†O image prompt CHI TI·∫æT

L∆ØU √ù:
- KH√îNG C·∫¶N ƒë√∫ng t√≠nh c√°ch nh√¢n v·∫≠t g·ªëc - quan tr·ªçng l√† B·ªêI C·∫¢NH QU·∫¢NG C√ÅO H·ª¢P L√ù
- S·∫£n ph·∫©m ph·∫£i xu·∫•t hi·ªán T·ª∞ NHI√äN trong tay/ƒëang s·ª≠ d·ª•ng
- Style v·∫Ω: ${artStyle?.name}, ${colorMode?.name}, ${lightingStyle?.name}`;

        const userPrompt = `**NH√ÇN V·∫¨T C√ì S·∫¥N** (ch·ªçn d·ª±a tr√™n ngo·∫°i h√¨nh, kh√¥ng c·∫ßn ƒë√∫ng t√≠nh c√°ch):
${charInfo}

**S·∫¢N PH·∫®M**: ${state.adProduct.name}

**Y√äU C·∫¶U B·ªêI C·∫¢NH**:
T·∫°o b·ªëi c·∫£nh H·ª¢P L√ù ƒë·ªÉ qu·∫£ng c√°o s·∫£n ph·∫©m n√†y. V√≠ d·ª•:
- N∆∞·ªõc gi·∫£i kh√°t ‚Üí tr·ªùi n√≥ng, sau t·∫≠p th·ªÉ thao, picnic, ti·ªác
- ƒê·ªì ƒÉn ‚Üí b·ªØa ƒÉn, qu√°n cafe, d√£ ngo·∫°i
- M·ªπ ph·∫©m ‚Üí selfie, g∆∞∆°ng, makeup
- ƒêi·ªán tho·∫°i ‚Üí ch·ª•p ·∫£nh, g·ªçi video, check social media

**ART STYLE**: ${artStyle?.name}, ${colorMode?.name}, ${lightingStyle?.name}

Tr·∫£ v·ªÅ JSON:
{
  "selected_characters": ["T√™n nh√¢n v·∫≠t 1"],
  "scene_description": "B·ªëi c·∫£nh H·ª¢P L√ù ƒë·ªÉ qu·∫£ng c√°o s·∫£n ph·∫©m - m√¥ t·∫£ chi ti·∫øt",
  "character_action": "Nh√¢n v·∫≠t ƒëang C·∫¶M/S·ª¨ D·ª§NG s·∫£n ph·∫©m nh∆∞ th·∫ø n√†o",
  "dialogue": "C√¢u tho·∫°i qu·∫£ng c√°o t·ª± nhi√™n, h·∫•p d·∫´n",
  "ad_slogan": "Slogan ng·∫Øn g·ªçn, catchy, b√°n h√†ng (ti·∫øng Vi·ªát)",
  "mood": "Kh√¥ng kh√≠ scene (vui v·∫ª, s·∫£ng kho√°i, sang tr·ªçng...)",
  "image_prompt": "ADVERTISEMENT COMIC PANEL. ${artStyle?.name} style, ${colorMode?.prompt}, ${lightingStyle?.prompt}. [M√î T·∫¢ NH√ÇN V·∫¨T: t√≥c, m·∫Øt, trang ph·ª•c]. [H√ÄNH ƒê·ªòNG v·ªõi s·∫£n ph·∫©m]. [B·ªêI C·∫¢NH ph√π h·ª£p qu·∫£ng c√°o]. Product ${state.adProduct.name} in character's hand ONLY - draw exactly like reference image. Speech bubble Vietnamese. High quality manga, TikTok vertical 9:16."
}`;

        console.log('üì¢ Calling DeepSeek to auto-create ad concept...');
        const data = await callTextAPI(systemPrompt, userPrompt, {
          temperature: 0.85,
          max_tokens: 2500
        });

        let content = data.choices[0].message.content;
        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const adData = JSON.parse(content);

        console.log('üì¢ DeepSeek created ad concept:', adData);
        console.log('   Selected characters:', adData.selected_characters);
        console.log('   Why:', adData.why_selected);

        // Generate image with product reference
        state.loadingMessage = 'ƒêang v·∫Ω panel qu·∫£ng c√°o v·ªõi ·∫£nh s·∫£n ph·∫©m...';
        render();

        // Build final image prompt with explicit reference to the attached image
        const finalImagePrompt = `Create an advertisement comic panel.

CHARACTERS: ${adData.selected_characters.join(', ')}
ACTION: ${adData.character_action}
SCENE: ${adData.scene_description}
MOOD: ${adData.mood}
DIALOGUE: "${adData.dialogue}"
SLOGAN: "${adData.ad_slogan}"

‚ö†Ô∏è PRODUCT PLACEMENT RULES:
The attached image shows the product "${state.adProduct.name}" that MUST appear in this comic panel.
- The product should ONLY appear in the character's HANDS or being USED by the character
- Draw the product to look EXACTLY like the reference image (same shape, colors, logo, packaging)
- The product must be clearly visible and recognizable
- DO NOT add extra product images in corners, borders, or floating in the scene
- DO NOT duplicate the product - show it ONCE, naturally held/used by the character

${adData.image_prompt}

IMPORTANT: The product appears ONLY where the character is holding/using it - nowhere else in the image. Include speech bubbles with Vietnamese dialogue.`;

        console.log('üì¢ Generating ad image with prompt:', finalImagePrompt);

        const imageResponse = await fetch('/api/gemini', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: finalImagePrompt,
            apiKey: state.geminiKey,
            referenceImage: state.adProduct.image
          })
        });

        const imageResult = await imageResponse.json();

        if (imageResult.imageData) {
          // Create ad panel object
          const adPanel = {
            type: 'advertisement',
            productName: state.adProduct.name,
            productImage: state.adProduct.image,
            selectedCharacters: adData.selected_characters,
            storyId: storyId,
            storyName: story.name,
            imageUrl: imageResult.imageData,
            adData: adData,
            createdAt: Date.now()
          };

          // Add to generated panels array
          state.generatedAdPanels.unshift(adPanel);
          console.log('üì¢ Ad Panel created:', adPanel);
        } else {
          throw new Error(imageResult.error || 'Failed to generate ad image');
        }

        state.adGenerating = false;
        state.loadingMessage = '';
        render();

      } catch (error) {
        console.error('‚ùå Ad generation error:', error);
        alert('L·ªói t·∫°o panel qu·∫£ng c√°o: ' + error.message);
        state.adGenerating = false;
        state.loadingMessage = '';
        render();
      }
    }

    // ===========================================
    // SERIES MODE: Helper Functions
    // ===========================================

    function nextEpisode() {
      if (state.currentEpisodeIndex < state.episodesPerSeries - 1) {
        state.currentEpisodeIndex++;
        state.storyData = null;
        state.panels = [];
        state.error = '';
        render();
      }
    }

    function viewEpisode(index) {
      if (index >= 0 && index < state.episodesPerSeries) {
        state.currentEpisodeIndex = index;
        if (state.episodes[index]) {
          state.panels = state.episodes[index].panels;
          state.storyData = {
            title: `${state.seriesOutline.series_title} - Episode ${index + 1}`,
            synopsis: state.seriesOutline.episodes[index].episode_synopsis,
            theme: state.seriesOutline.theme,
            characters: state.seriesOutline.characters
          };
        } else {
          state.panels = [];
          state.storyData = null;
        }
        render();
      }
    }

    async function generateCurrentEpisode() {
      await startGeneration();
    }

    // Continue to image generation after prompt approval
    async function continueToImageGeneration() {
      if (!state.promptsReady || !state.detailedPanels || state.detailedPanels.length === 0) {
        console.error('‚ùå No prompts ready for image generation');
        return;
      }

      try {
        console.log('üé® Starting image generation...');
        state.currentStep = 'images';
        state.progress = { current: 0, total: state.detailedPanels.length };
        state.promptsReady = false; // Reset flag
        render();

        const generatedPanels = [];
        for (let i = 0; i < state.detailedPanels.length; i++) {
          console.log(`\nüé® Panel ${i + 1}/${state.detailedPanels.length}: Generating image...`);
          state.progress.current = i + 1;
          render();

          try {
            const panel = await generateImage(state.detailedPanels[i].image_prompt, i + 1);
            generatedPanels.push({
              ...panel,
              panelData: state.detailedPanels[i]
            });
            console.log(`‚úÖ Panel ${i + 1} image generated`);
          } catch (imgErr) {
            console.error(`‚ùå Panel ${i + 1} image generation failed:`, imgErr);
            generatedPanels.push({
              panelNum: i + 1,
              error: imgErr.message,
              panelData: state.detailedPanels[i],
              prompt: state.detailedPanels[i].image_prompt
            });
          }

          state.panels = [...generatedPanels];
          render();

          // Rate limit delay
          if (i < state.detailedPanels.length - 1) {
            console.log('‚è≥ Waiting 2s before next panel...');
            await new Promise(r => setTimeout(r, 2000));
          }
        }

        // If Series Mode, save episode
        if (state.storyMode === 'series') {
          state.episodes[state.currentEpisodeIndex] = {
            episode_number: state.currentEpisodeIndex + 1,
            title: state.storyData.title,
            synopsis: state.storyData.synopsis,
            panels: generatedPanels
          };
          console.log(`üéâ Episode ${state.currentEpisodeIndex + 1} complete!`);

          // Auto-save story after episode completion
          console.log('üíæ Auto-saving story...');
          saveCurrentStory(true); // true = autoSave mode (no alert)
        }

        console.log('üéâ Image generation complete!');
        console.log('üìä Final stats:', {
          total: generatedPanels.length,
          successful: generatedPanels.filter(p => p.imageData).length,
          failed: generatedPanels.filter(p => p.error).length
        });

        state.currentStep = 'complete';
        render();

      } catch (err) {
        console.error('üí• Image generation failed:', err);
        state.error = err.message;
        state.currentStep = 'error';
        render();
      }
    }

    // Edit a specific panel prompt
    function editPanelPrompt(index) {
      const newPrompt = prompt('Ch·ªânh s·ª≠a prompt cho panel ' + (index + 1) + ':', state.detailedPanels[index].image_prompt);
      if (newPrompt !== null && newPrompt.trim() !== '') {
        state.detailedPanels[index].image_prompt = newPrompt.trim();
        // Also update in storyData
        if (state.storyData && state.storyData.image_prompts) {
          state.storyData.image_prompts[index] = newPrompt.trim();
        }
        render();
      }
    }

    // Render function
    function render() {
      const app = document.getElementById('app');
      renderRegenerateModal();
      renderAdRegenerateModal();
      renderStoryLibraryModal();

      app.innerHTML = `
        <div class="max-w-7xl mx-auto px-4 py-8">
          <!-- Header -->
          <header class="text-center mb-12">
            <div class="inline-flex items-center gap-3 mb-4">
              <span class="text-5xl">üé¨</span>
              <h1 class="text-4xl md:text-5xl font-black gradient-text">
                TikTok Comic Generator
              </h1>
              <span class="text-5xl">üì±</span>
            </div>
            <p class="text-slate-400 text-lg">
              T·∫°o truy·ªán tranh ho√†n ch·ªânh v·ªõi AI ‚Ä¢ DeepSeek story + Gemini art ‚Ä¢ T·ª± ƒë·ªông t·∫°o nh√¢n v·∫≠t
            </p>

            <!-- Main Tab Navigation -->
            <div class="flex justify-center gap-2 mt-6 mb-2">
              <button
                onclick="state.activeTab = 'story'; render();"
                class="px-6 py-3 rounded-xl font-bold text-lg transition-all ${
                  state.activeTab === 'story'
                    ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg shadow-purple-500/30'
                    : 'bg-slate-700/50 text-slate-400 hover:bg-slate-600/50 hover:text-white'
                }"
              >
                <span class="mr-2">üìñ</span> T·∫°o Truy·ªán
              </button>
              <button
                onclick="state.activeTab = 'ads'; render();"
                class="px-6 py-3 rounded-xl font-bold text-lg transition-all ${
                  state.activeTab === 'ads'
                    ? 'bg-gradient-to-r from-yellow-500 to-orange-500 text-white shadow-lg shadow-yellow-500/30'
                    : 'bg-slate-700/50 text-slate-400 hover:bg-slate-600/50 hover:text-white'
                }"
              >
                <span class="mr-2">üì¢</span> Qu·∫£ng C√°o
              </button>
            </div>

            <!-- Quick Actions Bar -->
            <div class="flex flex-wrap justify-center gap-3 mt-4">
              <button
                onclick="state.showStoryLibrary = true; render();"
                class="px-4 py-2 bg-gradient-to-r from-purple-500/20 to-pink-500/20 border border-purple-500/50 rounded-xl text-purple-300 font-medium hover:border-purple-400 transition-colors flex items-center gap-2"
              >
                <span>üìö</span> Th∆∞ vi·ªán (${state.savedStories.length})
              </button>

              ${(state.seriesOutline || state.storyData) ? `
                <button
                  onclick="saveCurrentStory()"
                  class="px-4 py-2 bg-gradient-to-r from-green-500/20 to-cyan-500/20 border border-green-500/50 rounded-xl text-green-300 font-medium hover:border-green-400 transition-colors flex items-center gap-2"
                >
                  <span>üíæ</span> L∆∞u truy·ªán
                </button>
              ` : ''}

              ${state.currentStoryId ? `
                <span class="px-3 py-2 bg-blue-500/10 border border-blue-500/30 rounded-xl text-blue-300 text-sm">
                  üìñ ${state.savedStories.find(s => s.id === state.currentStoryId)?.name || 'Untitled'}
                </span>
              ` : ''}
            </div>
          </header>

          ${state.showApiSetup ? renderApiSetup() : ''}

          ${state.activeTab === 'story' ? `
            <div class="grid lg:grid-cols-3 gap-8">
              <!-- Left Panel -->
              <div class="lg:col-span-1 space-y-6">
                ${renderGenreSelector()}
                ${renderArtStyleSelector()}
                ${renderStoryLengthSelector()}
                ${renderEmotionalToneSelector()}
                ${renderCharacterManager()}

                <button onclick="state.showApiSetup = true; render();"
                  class="w-full py-3 bg-slate-700/50 hover:bg-slate-600/50 rounded-xl text-slate-300 text-sm font-medium flex items-center justify-center gap-2 transition-colors">
                  ‚öôÔ∏è C√†i ƒë·∫∑t API Keys
                </button>
              </div>

              <!-- Right Panel -->
              <div class="lg:col-span-2 space-y-6">
                ${renderApiProviderSelector()}
                ${renderModeSelector()}
                ${renderStoryInput()}
                ${renderPromptReview()}
                ${state.seriesOutline ? renderSeriesRoadmap() : ''}
                ${state.storyData ? renderStoryInfo() : ''}
                ${state.panels.length > 0 ? renderPanelsGrid() : ''}
                ${state.panels.length === 0 && !state.storyData && state.currentStep === 'idle' ? renderEmptyState() : ''}
                ${renderNextEpisodeButton()}
                ${renderSeriesComplete()}
              </div>
            </div>
          ` : ''}

          ${state.activeTab === 'ads' ? renderAdGeneratorTab() : ''}

          <!-- Footer -->
          <footer class="mt-12 text-center text-slate-500 text-sm">
            <p>Powered by DeepSeek AI + Google Gemini ‚Ä¢ Made with üíú</p>
          </footer>
        </div>
      `;
    }

    function renderApiSetup() {
      const hasGemini = state.geminiKey.trim().length > 0;
      const hasDeepseek = state.deepseekKey.trim().length > 0;
      const canStart = hasGemini; // Ch·ªâ c·∫ßn Gemini key l√† ƒë·ªß

      return `
        <div class="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <div class="glass rounded-3xl p-8 max-w-lg w-full shadow-2xl max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold text-white mb-2 flex items-center gap-3">
              <span class="text-3xl">üîë</span> C√†i ƒë·∫∑t API Keys
            </h2>
            <p class="text-slate-400 mb-6 text-sm">
              Nh·∫≠p API keys ƒë·ªÉ s·ª≠ d·ª•ng. Keys ƒë∆∞·ª£c l∆∞u trong tr√¨nh duy·ªát c·ªßa b·∫°n.
            </p>

            <div class="space-y-4">
              <!-- Gemini API Key (Required) -->
              <div class="p-4 bg-green-500/10 border border-green-500/30 rounded-xl">
                <label class="block text-sm font-medium text-green-300 mb-2 flex items-center gap-2">
                  <span>üü¢</span> Gemini API Key <span class="text-pink-400">*</span>
                </label>
                <input
                  type="password"
                  value="${state.geminiKey}"
                  oninput="state.geminiKey = this.value.trim(); render();"
                  placeholder="AIza..."
                  class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-green-500 transition-all"
                />
                <p class="text-xs text-slate-400 mt-2">
                  <span class="text-green-400 font-bold">B·∫ÆT BU·ªòC</span> - D√πng cho:
                </p>
                <ul class="text-xs text-slate-500 mt-1 space-y-1">
                  <li>‚Ä¢ <span class="text-cyan-300">Gemini 3 Pro</span>: T·∫°o story & prompts (max 50 episodes!)</li>
                  <li>‚Ä¢ <span class="text-pink-300">Gemini 2.0 Flash</span>: T·∫°o h√¨nh ·∫£nh comic</li>
                </ul>
                <p class="text-xs text-slate-500 mt-2">
                  L·∫•y t·∫°i: <a href="https://aistudio.google.com/apikey" target="_blank" class="text-cyan-400 hover:underline">aistudio.google.com</a>
                </p>
              </div>

              <!-- DeepSeek API Key (Optional) -->
              <div class="p-4 bg-blue-500/10 border border-blue-500/30 rounded-xl">
                <label class="block text-sm font-medium text-blue-300 mb-2 flex items-center gap-2">
                  <span>üîµ</span> DeepSeek API Key <span class="text-slate-500">(t√πy ch·ªçn)</span>
                </label>
                <input
                  type="password"
                  value="${state.deepseekKey}"
                  oninput="state.deepseekKey = this.value.trim(); render();"
                  placeholder="sk-..."
                  class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                />
                <p class="text-xs text-slate-400 mt-2">
                  <span class="text-blue-400 font-bold">T√ôY CH·ªåN</span> - D√πng cho:
                </p>
                <ul class="text-xs text-slate-500 mt-1 space-y-1">
                  <li>‚Ä¢ <span class="text-blue-300">DeepSeek Chat</span>: T·∫°o story & prompts (max 12 episodes)</li>
                  <li>‚Ä¢ ·ªîn ƒë·ªãnh, nhanh, thay th·∫ø cho Gemini 3 Pro</li>
                </ul>
                <p class="text-xs text-slate-500 mt-2">
                  L·∫•y t·∫°i: <a href="https://platform.deepseek.com" target="_blank" class="text-cyan-400 hover:underline">platform.deepseek.com</a>
                </p>
              </div>
            </div>

            <!-- Status -->
            <div class="mt-4 p-3 bg-slate-800/50 rounded-xl text-xs">
              <p class="text-slate-400">
                <span class="font-bold">Text API c√≥ s·∫µn:</span>
                ${hasGemini ? '<span class="text-green-400 ml-2">‚úÖ Gemini 3 Pro</span>' : '<span class="text-red-400 ml-2">‚ùå Gemini</span>'}
                ${hasDeepseek ? '<span class="text-blue-400 ml-2">‚úÖ DeepSeek</span>' : '<span class="text-slate-500 ml-2">‚óã DeepSeek</span>'}
              </p>
              <p class="text-slate-400 mt-1">
                <span class="font-bold">Image API:</span>
                ${hasGemini ? '<span class="text-green-400 ml-2">‚úÖ Gemini 2.0 Flash</span>' : '<span class="text-red-400 ml-2">‚ùå C·∫ßn Gemini key</span>'}
              </p>
            </div>

            <button
              onclick="saveApiKeys()"
              ${!canStart ? 'disabled' : ''}
              class="w-full mt-6 py-4 gradient-btn rounded-xl font-bold text-white text-lg disabled:opacity-50 disabled:cursor-not-allowed hover:shadow-lg transition-all transform hover:scale-[1.02] active:scale-[0.98]"
            >
              ${canStart ? 'B·∫Øt ƒë·∫ßu s√°ng t·∫°o! üöÄ' : '‚ö†Ô∏è C·∫ßn √≠t nh·∫•t Gemini API Key'}
            </button>
          </div>
        </div>
      `;
    }

    function renderGenreSelector() {
      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üìö</span> Th·ªÉ lo·∫°i
          </h3>
          <div class="grid grid-cols-2 gap-2">
            ${GENRES.map(g => `
              <button
                onclick="state.genre = '${g.id}'; render();"
                class="p-3 rounded-xl text-left transition-all transform hover:scale-105 ${
                  state.genre === g.id 
                    ? 'bg-gradient-to-r from-pink-500/20 to-purple-500/20 border-2 border-pink-500' 
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
              >
                <span class="text-xl">${g.icon}</span>
                <p class="text-sm text-white font-medium mt-1">${g.name}</p>
              </button>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderArtStyleSelector() {
      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üé®</span> Phong c√°ch v·∫Ω
          </h3>
          <div class="grid grid-cols-2 gap-2">
            ${ART_STYLES.map(s => `
              <button
                onclick="state.artStyle = '${s.id}'; render();"
                class="p-3 rounded-xl text-center transition-all ${
                  state.artStyle === s.id
                    ? 'bg-gradient-to-r from-cyan-500/20 to-blue-500/20 border-2 border-cyan-500'
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
              >
                <p class="text-xs text-slate-400">${s.preview}</p>
                <p class="text-sm text-white font-medium">${s.name}</p>
              </button>
            `).join('')}
          </div>

          <!-- Color Mode -->
          <h4 class="text-sm font-bold text-white mt-5 mb-3 flex items-center gap-2">
            <span>üñåÔ∏è</span> Ch·∫ø ƒë·ªô m√†u <span class="text-xs text-slate-400">(th·ªëng nh·∫•t xuy√™n su·ªët)</span>
          </h4>
          <div class="grid grid-cols-2 gap-2">
            ${COLOR_MODES.map(c => `
              <button
                onclick="state.colorMode = '${c.id}'; localStorage.setItem('colorMode', '${c.id}'); render();"
                class="p-2 rounded-lg text-center transition-all ${
                  state.colorMode === c.id
                    ? 'bg-gradient-to-r from-pink-500/20 to-orange-500/20 border-2 border-pink-500'
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
              >
                <span class="text-lg">${c.icon}</span>
                <p class="text-xs text-white font-medium">${c.name}</p>
              </button>
            `).join('')}
          </div>

          <!-- Lighting Style -->
          <h4 class="text-sm font-bold text-white mt-5 mb-3 flex items-center gap-2">
            <span>üí°</span> √Ånh s√°ng ch·ªß ƒë·∫°o
          </h4>
          <div class="grid grid-cols-5 gap-1">
            ${LIGHTING_STYLES.map(l => `
              <button
                onclick="state.lightingStyle = '${l.id}'; localStorage.setItem('lightingStyle', '${l.id}'); render();"
                class="p-2 rounded-lg text-center transition-all ${
                  state.lightingStyle === l.id
                    ? 'bg-gradient-to-r from-yellow-500/20 to-orange-500/20 border-2 border-yellow-500'
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
                title="${l.name}"
              >
                <span class="text-lg">${l.icon}</span>
                <p class="text-[10px] text-white">${l.name}</p>
              </button>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderStoryLengthSelector() {
      // Calculate max safe panels based on genre (only for single-stage)
      const genreMultiplier = ['action', 'fantasy'].includes(state.genre) ? 700 : 600;
      const maxSafePanels = Math.floor((8192 - 1500) / genreMultiplier);
      const willTruncate = state.generationMode === 'single-stage' && state.panelCount * genreMultiplier + 1500 > 8192;

      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üìè</span> ƒê·ªô d√†i truy·ªán
            ${state.generationMode === 'two-stage' ? '<span class="text-xs text-green-400 ml-2">‚ú® Unlimited!</span>' : ''}
          </h3>
          <div class="space-y-2">
            ${STORY_LENGTHS.map(length => `
              <button
                onclick="state.storyLength = '${length.id}'; state.panelCount = ${length.panels}; render();"
                class="w-full p-3 rounded-xl text-left transition-all ${
                  state.storyLength === length.id
                    ? 'bg-gradient-to-r from-purple-500/20 to-blue-500/20 border-2 border-purple-500'
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
              >
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-xl">${length.icon}</span>
                  <span class="text-white font-medium">${length.name}</span>
                </div>
                <p class="text-xs text-slate-400">${length.desc}</p>
              </button>
            `).join('')}
          </div>
          <div class="mt-3 pt-3 border-t border-slate-600">
            <label class="text-xs text-slate-400 mb-2 block">T√πy ch·ªânh ch√≠nh x√°c${state.generationMode === 'single-stage' ? ` (max khuy·∫øn ngh·ªã: ${maxSafePanels})` : ' (t·ªëi ƒëa 50)'}:</label>
            <input
              type="range"
              min="3"
              max="50"
              value="${state.panelCount}"
              oninput="state.panelCount = parseInt(this.value); render();"
              class="w-full cursor-pointer"
            />
            <p class="text-center text-white font-bold mt-1">${state.panelCount} panels</p>
            ${willTruncate ? `
              <div class="mt-2 p-2 bg-yellow-500/20 border border-yellow-500/50 rounded-lg">
                <p class="text-xs text-yellow-300 flex items-start gap-2">
                  <span>‚ö†Ô∏è</span>
                  <span><strong>${state.panelCount} panels</strong> c√≥ th·ªÉ b·ªã c·∫Øt c·ª•t trong Single-stage mode! Khuy·∫øn ngh·ªã t·ªëi ƒëa <strong>${maxSafePanels} panels</strong> cho th·ªÉ lo·∫°i ${GENRES.find(g => g.id === state.genre)?.name}.</span>
                </p>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    function renderEmotionalToneSelector() {
      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üí´</span> C∆∞·ªùng ƒë·ªô c·∫£m x√∫c
          </h3>
          <div class="space-y-2">
            ${EMOTIONAL_TONES.map(tone => `
              <button
                onclick="state.emotionalIntensity = '${tone.id}'; render();"
                class="w-full p-3 rounded-xl text-left transition-all ${
                  state.emotionalIntensity === tone.id
                    ? 'bg-gradient-to-r from-pink-500/20 to-orange-500/20 border-2 border-pink-500'
                    : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
                }"
              >
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-xl">${tone.icon}</span>
                  <span class="text-white font-medium">${tone.name}</span>
                </div>
                <p class="text-xs text-slate-400">${tone.desc}</p>
              </button>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderCharacterManager() {
      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üë•</span> Nh√¢n v·∫≠t ch√≠nh
          </h3>
          <p class="text-xs text-slate-400 mb-4">
            ƒê·ªãnh nghƒ©a nh√¢n v·∫≠t ƒë·ªÉ gi·ªØ nh·∫•t qu√°n qua c√°c panel
          </p>
          
          ${state.characters.map(char => `
            <div class="mb-3 p-3 bg-slate-700/50 rounded-xl relative group">
              <button
                onclick="removeCharacter(${char.id})"
                class="absolute -top-2 -right-2 w-6 h-6 bg-red-500 rounded-full text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center"
              >
                ‚úï
              </button>
              <p class="font-medium text-white">${char.name}</p>
              <p class="text-xs text-slate-400 mt-1">${char.description}</p>
            </div>
          `).join('')}
          
          <div class="space-y-2 mt-4">
            <input
              type="text"
              value="${state.newCharName}"
              oninput="state.newCharName = this.value"
              placeholder="T√™n nh√¢n v·∫≠t"
              class="w-full px-3 py-2 bg-slate-900/50 border border-slate-600 rounded-lg text-white placeholder-slate-500 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
            />
            <textarea
              oninput="state.newCharDesc = this.value"
              placeholder="M√¥ t·∫£: tu·ªïi, gi·ªõi t√≠nh, t√≥c, m·∫Øt, trang ph·ª•c..."
              rows="2"
              class="w-full px-3 py-2 bg-slate-900/50 border border-slate-600 rounded-lg text-white placeholder-slate-500 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
            >${state.newCharDesc}</textarea>
            <button
              onclick="addCharacter()"
              class="w-full py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm text-white font-medium transition-colors"
            >
              + Th√™m nh√¢n v·∫≠t
            </button>
          </div>
        </div>
      `;
    }


    function renderApiProviderSelector() {
      const currentLimits = getCurrentLimits();
      const hasDeepseekKey = state.deepseekKey.trim().length > 0;
      const hasGeminiKey = state.geminiKey.trim().length > 0;

      return `
        <div class="glass rounded-2xl p-6 mb-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>ü§ñ</span> Text API Provider
          </h3>
          <div class="grid grid-cols-2 gap-3">
            <button
              onclick="switchTextProvider('deepseek')"
              ${!hasDeepseekKey ? 'disabled' : ''}
              class="p-4 rounded-xl text-left transition-all transform hover:scale-105 ${
                state.textApiProvider === 'deepseek'
                  ? 'bg-gradient-to-r from-blue-500/20 to-indigo-500/20 border-2 border-blue-500'
                  : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
              } ${!hasDeepseekKey ? 'opacity-50 cursor-not-allowed' : ''}"
            >
              <div class="flex items-center gap-2 mb-2">
                <span class="text-2xl">üîµ</span>
                <span class="text-white font-bold">DeepSeek</span>
              </div>
              <p class="text-xs text-slate-400">
                ${API_LIMITS.deepseek.description}
              </p>
              <p class="text-xs text-blue-300 mt-1">
                Max ${API_LIMITS.deepseek.maxEpisodes} episodes
              </p>
              ${!hasDeepseekKey ? '<p class="text-xs text-red-400 mt-1">‚ö†Ô∏è Ch∆∞a c√≥ API key</p>' : ''}
            </button>

            <button
              onclick="switchTextProvider('gemini')"
              ${!hasGeminiKey ? 'disabled' : ''}
              class="p-4 rounded-xl text-left transition-all transform hover:scale-105 ${
                state.textApiProvider === 'gemini'
                  ? 'bg-gradient-to-r from-green-500/20 to-cyan-500/20 border-2 border-green-500'
                  : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
              } ${!hasGeminiKey ? 'opacity-50 cursor-not-allowed' : ''}"
            >
              <div class="flex items-center gap-2 mb-2">
                <span class="text-2xl">üü¢</span>
                <span class="text-white font-bold">Gemini 3 Pro</span>
                <span class="px-2 py-0.5 bg-gradient-to-r from-green-500 to-cyan-500 rounded-full text-xs font-bold text-white">
                  NEW
                </span>
              </div>
              <p class="text-xs text-slate-400">
                ${API_LIMITS.gemini.description}
              </p>
              <p class="text-xs text-green-300 mt-1">
                Max ${API_LIMITS.gemini.maxEpisodes} episodes!
              </p>
              ${!hasGeminiKey ? '<p class="text-xs text-red-400 mt-1">‚ö†Ô∏è Ch∆∞a c√≥ API key</p>' : ''}
            </button>
          </div>

          <div class="mt-3 p-3 bg-slate-800/50 rounded-lg text-xs">
            <p class="text-slate-400">
              <span class="text-white font-bold">ƒêang d√πng:</span> ${currentLimits.name}
            </p>
            <p class="text-slate-400">
              <span class="text-white font-bold">Output tokens:</span> ${currentLimits.maxOutputTokens.toLocaleString()}
            </p>
          </div>

          <!-- Hybrid Mode Toggle -->
          ${hasDeepseekKey && hasGeminiKey ? `
            <div class="mt-4 p-4 rounded-xl border-2 ${state.hybridMode
              ? 'bg-gradient-to-r from-purple-500/20 to-pink-500/20 border-purple-500'
              : 'bg-slate-700/30 border-slate-600'}">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="text-2xl">‚ö°</span>
                  <div>
                    <p class="text-white font-bold">Hybrid Mode</p>
                    <p class="text-xs text-slate-400">Gemini t·∫°o outline + DeepSeek t·∫°o panels</p>
                  </div>
                </div>
                <button
                  onclick="state.hybridMode = !state.hybridMode; localStorage.setItem('hybridMode', state.hybridMode); render();"
                  class="px-4 py-2 rounded-lg font-bold text-sm transition ${state.hybridMode
                    ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white'
                    : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}"
                >
                  ${state.hybridMode ? '‚úì B·∫¨T' : 'T·∫ÆT'}
                </button>
              </div>
              ${state.hybridMode ? `
                <div class="mt-3 p-2 bg-purple-500/10 rounded-lg">
                  <p class="text-xs text-purple-300">
                    <span class="font-bold">üü¢ Gemini:</span> T·∫°o series outline theo chunks (15 chap/batch)
                  </p>
                  <p class="text-xs text-purple-300 mt-1">
                    <span class="font-bold">üîµ DeepSeek:</span> T·∫°o chi ti·∫øt panels cho t·ª´ng chap
                  </p>
                  <p class="text-xs text-green-300 mt-2">
                    ‚úÖ H·ªó tr·ª£ 100-200 chap ƒë·∫ßy ƒë·ªß, kh√¥ng b·ªã c·∫Øt!
                  </p>
                </div>
              ` : ''}
            </div>
          ` : `
            <div class="mt-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600">
              <p class="text-xs text-slate-400">
                üí° <span class="text-yellow-300">Hybrid Mode</span>: C·∫ßn c·∫£ 2 API keys (DeepSeek + Gemini) ƒë·ªÉ b·∫≠t ch·∫ø ƒë·ªô k·∫øt h·ª£p
              </p>
            </div>
          `}
        </div>
      `;
    }

    function renderModeSelector() {
      return `
        <div class="glass rounded-2xl p-6 mb-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>üìñ</span> Story Mode
          </h3>
          <div class="grid grid-cols-2 gap-3">
            <button
              onclick="state.storyMode = 'single'; render();"
              class="p-4 rounded-xl text-left transition-all transform hover:scale-105 ${
                state.storyMode === 'single'
                  ? 'bg-gradient-to-r from-pink-500/20 to-purple-500/20 border-2 border-pink-500'
                  : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
              }"
            >
              <div class="flex items-center gap-2 mb-2">
                <span class="text-2xl">üìñ</span>
                <span class="text-white font-bold">Single Story</span>
              </div>
              <p class="text-xs text-slate-400">
                M·ªôt c√¢u chuy·ªán ho√†n ch·ªânh, t·ªëi ƒëa 50 panels
              </p>
            </button>

            <button
              onclick="state.storyMode = 'series'; render();"
              class="p-4 rounded-xl text-left transition-all transform hover:scale-105 ${
                state.storyMode === 'series'
                  ? 'bg-gradient-to-r from-cyan-500/20 to-blue-500/20 border-2 border-cyan-500'
                  : 'bg-slate-700/50 border border-slate-600 hover:border-slate-500'
              }"
            >
              <div class="flex items-center gap-2 mb-2">
                <span class="text-2xl">üì∫</span>
                <span class="text-white font-bold">Series</span>
                <span class="px-2 py-0.5 bg-gradient-to-r from-yellow-500 to-orange-500 rounded-full text-xs font-bold text-white">
                  HOT
                </span>
              </div>
              <p class="text-xs text-slate-400">
                ƒê·∫øn ${getEffectiveLimits().maxEpisodes} chap √ó ${getEffectiveLimits().maxPanelsPerEpisode} panels/chap
              </p>
            </button>
          </div>
        </div>

        ${state.storyMode === 'series' ? `
          <div class="glass rounded-2xl p-6 mb-6">
            <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
              <span>‚öôÔ∏è</span> C·∫•u h√¨nh Series
            </h3>

            <!-- Episodes Count -->
            <div class="mb-5">
              <label class="text-sm text-slate-300 mb-2 block">
                S·ªë chap: <span class="text-white font-bold text-lg">${state.episodesPerSeries}</span>
                <span class="text-xs text-slate-500">(max ${getEffectiveLimits().maxEpisodes} v·ªõi ${getEffectiveLimits().name})</span>
              </label>
              <input
                type="range"
                min="5"
                max="${getEffectiveLimits().maxEpisodes}"
                value="${state.episodesPerSeries}"
                oninput="state.episodesPerSeries = parseInt(this.value); render();"
                class="w-full cursor-pointer"
              />
              <div class="flex justify-between text-xs text-slate-500 mt-1">
                <span>5 chap</span>
                <span>${getEffectiveLimits().maxEpisodes} chap</span>
              </div>
            </div>

            <!-- Panels per Episode -->
            <div class="mb-5">
              <label class="text-sm text-slate-300 mb-2 block">
                Panels/chap: <span class="text-white font-bold text-lg">${state.panelsPerEpisode}</span>
                <span class="text-xs text-slate-500">(max ${getCurrentLimits().maxPanelsPerEpisode})</span>
              </label>
              <input
                type="range"
                min="8"
                max="${getCurrentLimits().maxPanelsPerEpisode}"
                value="${state.panelsPerEpisode}"
                oninput="state.panelsPerEpisode = parseInt(this.value); render();"
                class="w-full cursor-pointer"
              />
              <div class="flex justify-between text-xs text-slate-500 mt-1">
                <span>8 panels (ng·∫Øn)</span>
                <span>${getCurrentLimits().maxPanelsPerEpisode} panels</span>
              </div>
            </div>

            <!-- Token Warning -->
            ${(() => {
              const warning = getTokenWarning();
              if (!warning.show) return '';
              const isError = warning.severity === 'error';
              return `
                <div class="mb-4 p-3 rounded-lg border ${isError
                  ? 'bg-red-500/20 border-red-500/50'
                  : 'bg-yellow-500/20 border-yellow-500/50'}">
                  <div class="flex items-start gap-2">
                    <span class="text-lg">${isError ? 'üö®' : '‚ö†Ô∏è'}</span>
                    <div>
                      <p class="text-sm ${isError ? 'text-red-300' : 'text-yellow-300'} font-bold mb-1">
                        ${isError ? 'S·∫Ω b·ªã c·∫Øt n·ªôi dung!' : 'C√≥ th·ªÉ b·ªã c·∫Øt n·ªôi dung'}
                      </p>
                      <p class="text-xs ${isError ? 'text-red-200/80' : 'text-yellow-200/80'} mb-2">
                        ${warning.message}
                      </p>
                      <p class="text-xs ${isError ? 'text-red-300' : 'text-yellow-300'}">
                        üí° ${warning.suggestion}
                      </p>
                      ${state.textApiProvider === 'deepseek' ? `
                        <button
                          onclick="switchTextProvider('gemini'); render();"
                          class="mt-2 px-3 py-1 bg-gradient-to-r from-cyan-500 to-blue-500 text-white text-xs font-bold rounded-lg hover:opacity-90 transition"
                        >
                          üöÄ Chuy·ªÉn sang Gemini 3 Pro (65k tokens)
                        </button>
                      ` : ''}
                    </div>
                  </div>
                </div>
              `;
            })()}

            <!-- Summary -->
            <div class="p-3 bg-gradient-to-r from-purple-500/10 to-cyan-500/10 border border-purple-500/30 rounded-lg">
              <p class="text-sm text-purple-300 mb-2">
                <span class="font-bold">üìä T·ªïng quan Series:</span>
              </p>
              <div class="grid grid-cols-2 gap-2 text-xs">
                <div class="bg-slate-800/50 p-2 rounded">
                  <span class="text-slate-400">S·ªë chap:</span>
                  <span class="text-white font-bold ml-1">${state.episodesPerSeries}</span>
                  ${!state.hybridMode ? `<span class="text-xs text-slate-500 ml-1">(an to√†n: ‚â§${getMaxSafeEpisodes()})</span>` : ''}
                </div>
                <div class="bg-slate-800/50 p-2 rounded">
                  <span class="text-slate-400">Panels/chap:</span>
                  <span class="text-white font-bold ml-1">${state.panelsPerEpisode}</span>
                </div>
                <div class="col-span-2 bg-yellow-500/10 p-2 rounded border border-yellow-500/30">
                  <span class="text-yellow-300">T·ªïng panels:</span>
                  <span class="text-yellow-400 font-bold text-lg ml-1">${state.episodesPerSeries * state.panelsPerEpisode}</span>
                  <span class="text-yellow-300/70 text-[10px] ml-1">panels</span>
                </div>
              </div>
              <p class="text-[10px] text-slate-500 mt-2">
                ${state.hybridMode
                  ? '‚ö° Hybrid Mode: Gemini t·∫°o outline (chunks 15 chap), DeepSeek t·∫°o panels. H·ªó tr·ª£ 100-200 chap!'
                  : `üí° V·ªõi ${getEffectiveLimits().name}: Max an to√†n ${getMaxSafeEpisodes()} chap. Chap ng·∫Øn d·ªÖ ƒë·ªçc tr√™n mobile!`}
              </p>
            </div>
          </div>
        ` : ''}
      `;
    }

    function renderStoryInput() {
      const isLoading = state.currentStep === 'story' || state.currentStep === 'images' || state.currentStep === 'outline' || state.currentStep === 'panel-details' || state.currentStep === 'awaiting-approval';

      return `
        <div class="glass rounded-2xl p-6">
          <h3 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <span>‚ú®</span> √ù t∆∞·ªüng truy·ªán
          </h3>
          <textarea
            oninput="state.storyPrompt = this.value"
            placeholder="VD: M·ªôt ch√†ng trai g·∫∑p l·∫°i m·ªëi t√¨nh ƒë·∫ßu sau 10 nƒÉm t·∫°i qu√°n c√† ph√™, nh∆∞ng c√¥ ·∫•y kh√¥ng nh·∫≠n ra anh..."
            rows="4"
            class="w-full px-4 py-3 bg-slate-900/50 border border-slate-600 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
          >${state.storyPrompt}</textarea>
          
          <button
            onclick="startGeneration()"
            ${isLoading ? 'disabled' : ''}
            class="w-full mt-4 py-4 gradient-btn rounded-xl font-bold text-white text-lg disabled:opacity-50 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-3"
          >
            ${state.currentStep === 'outline' ? `<span class="animate-spin">üìã</span> ${state.loadingMessage || 'ƒêang t·∫°o story outline...'}` : ''}
            ${state.currentStep === 'panel-details' ? `<span class="animate-spin">üìù</span> ƒêang t·∫°o chi ti·∫øt panel ${state.progress.current}/${state.progress.total}...` : ''}
            ${state.currentStep === 'awaiting-approval' ? '‚è∏Ô∏è ƒêang ch·ªù duy·ªát prompts...' : ''}
            ${state.currentStep === 'story' ? '<span class="animate-spin">‚öôÔ∏è</span> ƒêang t·∫°o c·ªët truy·ªán...' : ''}
            ${state.currentStep === 'images' ? `<span class="animate-pulse">üé®</span> ƒêang v·∫Ω panel ${state.progress.current}/${state.progress.total}...` : ''}
            ${!isLoading ? 'üöÄ T·∫°o truy·ªán tranh' : ''}
          </button>
          
          ${state.error ? `
            <div class="mt-4 p-4 bg-red-500/20 border border-red-500/50 rounded-xl text-red-300 text-sm">
              <div class="flex items-start gap-3">
                <span class="text-2xl">‚ö†Ô∏è</span>
                <div class="flex-1">
                  <p class="font-bold mb-2">L·ªói x·∫£y ra:</p>
                  <p class="whitespace-pre-wrap">${state.error}</p>
                  <div class="mt-3 flex gap-2">
                    <button
                      onclick="console.log('Error details:', state.error); alert('Check browser console (F12) for detailed logs');"
                      class="px-3 py-1 bg-red-500/30 hover:bg-red-500/40 rounded-lg text-xs transition-colors"
                    >
                      üîç Xem chi ti·∫øt (Console)
                    </button>
                    <button
                      onclick="navigator.clipboard.writeText(state.error); alert('ƒê√£ copy error message!');"
                      class="px-3 py-1 bg-red-500/30 hover:bg-red-500/40 rounded-lg text-xs transition-colors"
                    >
                      üìã Copy l·ªói
                    </button>
                  </div>
                </div>
              </div>
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderPromptReview() {
      if (!state.promptsReady || !state.detailedPanels || state.detailedPanels.length === 0) return '';

      return `
        <div class="glass rounded-2xl p-6 mb-6">
          <div class="mb-6">
            <h3 class="text-2xl font-bold text-white mb-2 flex items-center gap-2">
              <span>üìù</span> Duy·ªát Prompts (${state.detailedPanels.length} panels)
            </h3>
            <p class="text-slate-300 text-sm mb-4">
              Ki·ªÉm tra v√† ch·ªânh s·ª≠a prompts tr∆∞·ªõc khi t·∫°o h√¨nh ·∫£nh. Click v√†o prompt ƒë·ªÉ ch·ªânh s·ª≠a.
            </p>

            <div class="flex gap-3 mb-4">
              <button
                onclick="continueToImageGeneration()"
                class="flex-1 py-4 bg-gradient-to-r from-green-500 to-cyan-500 hover:from-green-600 hover:to-cyan-600 rounded-xl font-bold text-white text-lg transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-3"
              >
                <span class="text-2xl">üé®</span>
                Ti·∫øp t·ª•c t·∫°o h√¨nh ·∫£nh
                <span class="text-sm opacity-80">(${state.detailedPanels.length} panels)</span>
              </button>
            </div>
          </div>

          <!-- Prompts Grid -->
          <div class="space-y-3 max-h-[600px] overflow-y-auto pr-2">
            ${state.detailedPanels.map((panel, i) => `
              <div class="p-4 bg-slate-800/50 border border-slate-600 rounded-xl hover:border-purple-500/50 transition-colors">
                <div class="flex items-start justify-between mb-2">
                  <span class="text-sm font-bold text-purple-300">Panel ${i + 1}</span>
                  <button
                    onclick="editPanelPrompt(${i})"
                    class="px-3 py-1 bg-blue-500/20 hover:bg-blue-500/30 border border-blue-500/50 rounded-lg text-blue-300 text-xs font-medium transition-colors"
                  >
                    ‚úèÔ∏è S·ª≠a
                  </button>
                </div>

                <div class="mb-2">
                  <p class="text-xs text-slate-400 mb-1">Scene:</p>
                  <p class="text-sm text-slate-200">${panel.scene_description || 'N/A'}</p>
                </div>

                ${panel.dialogue ? `
                  <div class="mb-2">
                    <p class="text-xs text-slate-400 mb-1">Dialogue:</p>
                    <p class="text-sm text-green-200">"${panel.dialogue}"</p>
                  </div>
                ` : ''}

                <div class="mt-3 p-3 bg-slate-900/50 rounded-lg">
                  <p class="text-xs text-slate-400 mb-1">Image Prompt:</p>
                  <p class="text-xs text-slate-300 font-mono break-words">${panel.image_prompt}</p>
                </div>
              </div>
            `).join('')}
          </div>

          <!-- Bottom Action Button -->
          <div class="mt-6 pt-6 border-t border-slate-600">
            <button
              onclick="continueToImageGeneration()"
              class="w-full py-4 bg-gradient-to-r from-green-500 to-cyan-500 hover:from-green-600 hover:to-cyan-600 rounded-xl font-bold text-white text-lg transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-3"
            >
              <span class="text-2xl">üöÄ</span>
              X√°c nh·∫≠n & T·∫°o ${state.detailedPanels.length} h√¨nh ·∫£nh
            </button>
          </div>
        </div>
      `;
    }

    function renderSeriesRoadmap() {
      if (!state.seriesOutline) return '';

      // Pagination logic
      const totalEpisodes = state.seriesOutline.episodes.length;
      const totalPages = Math.ceil(totalEpisodes / state.episodesPerPage);
      const currentPage = Math.min(state.episodeListPage, totalPages - 1);
      const startIdx = currentPage * state.episodesPerPage;
      const endIdx = Math.min(startIdx + state.episodesPerPage, totalEpisodes);
      const visibleEpisodes = state.seriesOutline.episodes.slice(startIdx, endIdx);

      // Check for missing episodes (gaps in episode numbers)
      const existingEpNumbers = state.seriesOutline.episodes.map(e => e.episode_number);
      const expectedEps = Array.from({ length: state.episodesPerSeries }, (_, i) => i + 1);
      const missingEps = expectedEps.filter(n => !existingEpNumbers.includes(n));

      return `
        <div class="glass rounded-2xl p-6 mb-6">
          <div class="flex items-start justify-between mb-4">
            <div class="flex-1">
              <h3 class="text-3xl font-black text-white mb-2 flex items-center gap-2">
                üì∫ ${state.seriesOutline.series_title}
              </h3>
              <p class="text-slate-300 text-sm mb-2">${state.seriesOutline.series_synopsis}</p>
              <div class="flex flex-wrap gap-2 text-xs">
                <span class="px-2 py-1 bg-purple-500/20 border border-purple-500/30 rounded-full text-purple-300">
                  ${state.seriesOutline.theme}
                </span>
                <span class="px-2 py-1 bg-cyan-500/20 border border-cyan-500/30 rounded-full text-cyan-300">
                  ${totalEpisodes}/${state.episodesPerSeries} Episodes
                </span>
                <span class="px-2 py-1 bg-green-500/20 border border-green-500/30 rounded-full text-green-300">
                  üë• ${state.seriesOutline.characters?.length || 0} Nh√¢n v·∫≠t
                </span>
              </div>
            </div>
          </div>

          <!-- Failed Batches Warning -->
          ${state.failedBatches.length > 0 ? `
            <div class="mb-4 p-4 bg-red-500/10 border-2 border-red-500/50 rounded-xl">
              <div class="flex items-center justify-between mb-2">
                <h4 class="text-red-300 font-bold flex items-center gap-2">
                  ‚ö†Ô∏è C√≥ ${state.failedBatches.length} batch b·ªã l·ªói
                </h4>
                <button
                  onclick="retryFailedBatches()"
                  ${state.isRetrying ? 'disabled' : ''}
                  class="px-4 py-2 bg-red-500 hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-white font-bold text-sm transition-colors flex items-center gap-2"
                >
                  ${state.isRetrying ? `
                    <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    ƒêang retry...
                  ` : 'üîÑ Retry t·∫•t c·∫£'}
                </button>
              </div>
              <div class="space-y-1">
                ${state.failedBatches.map(batch => `
                  <div class="text-xs text-red-200/80 flex items-center gap-2">
                    <span class="text-red-400">‚úó</span>
                    <span>Chap ${batch.startEp}-${batch.endEp}:</span>
                    <span class="text-red-300/60 truncate">${batch.error}</span>
                  </div>
                `).join('')}
              </div>
              ${missingEps.length > 0 ? `
                <div class="mt-2 pt-2 border-t border-red-500/30">
                  <p class="text-xs text-red-200/80">
                    <span class="font-bold">Chap b·ªã thi·∫øu:</span> ${missingEps.length > 10 ? missingEps.slice(0, 10).join(', ') + '...' : missingEps.join(', ')}
                  </p>
                </div>
              ` : ''}
            </div>
          ` : ''}

          <!-- Missing Episodes Warning (when no failedBatches but episodes are missing) -->
          ${state.failedBatches.length === 0 && missingEps.length > 0 ? `
            <div class="mb-4 p-4 bg-orange-500/10 border-2 border-orange-500/50 rounded-xl">
              <div class="flex items-center justify-between mb-2">
                <h4 class="text-orange-300 font-bold flex items-center gap-2">
                  ‚ö†Ô∏è Thi·∫øu ${missingEps.length} episode (${totalEpisodes}/${state.episodesPerSeries})
                </h4>
                <button
                  onclick="regenerateMissingEpisodes()"
                  ${state.isRetrying ? 'disabled' : ''}
                  class="px-4 py-2 bg-orange-500 hover:bg-orange-600 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-white font-bold text-sm transition-colors flex items-center gap-2"
                >
                  ${state.isRetrying ? `
                    <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    ƒêang t√°i t·∫°o...
                  ` : 'üîÑ T√°i t·∫°o episodes thi·∫øu'}
                </button>
              </div>
              <div class="text-xs text-orange-200/80">
                <span class="font-bold">Chap b·ªã thi·∫øu:</span>
                ${missingEps.length > 15
                  ? missingEps.slice(0, 15).join(', ') + '... (+' + (missingEps.length - 15) + ' chap n·ªØa)'
                  : missingEps.join(', ')
                }
              </div>
            </div>
          ` : ''}

          <!-- Episodes Grid with Pagination -->
          <div class="mt-6">
            <div class="flex items-center justify-between mb-3">
              <h4 class="text-sm font-bold text-slate-400 flex items-center gap-2">
                <span>üìö</span> EPISODES (${startIdx + 1}-${endIdx} / ${totalEpisodes})
              </h4>

              <!-- Pagination Controls -->
              ${totalPages > 1 ? `
                <div class="flex items-center gap-2">
                  <button
                    onclick="state.episodeListPage = 0; render();"
                    ${currentPage === 0 ? 'disabled' : ''}
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 disabled:cursor-not-allowed rounded text-white text-xs transition-colors"
                  >‚èÆ</button>
                  <button
                    onclick="state.episodeListPage = Math.max(0, state.episodeListPage - 1); render();"
                    ${currentPage === 0 ? 'disabled' : ''}
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 disabled:cursor-not-allowed rounded text-white text-xs transition-colors"
                  >‚óÄ</button>
                  <span class="px-3 py-1 bg-purple-500/20 rounded text-purple-300 text-xs font-bold">
                    ${currentPage + 1} / ${totalPages}
                  </span>
                  <button
                    onclick="state.episodeListPage = Math.min(${totalPages - 1}, state.episodeListPage + 1); render();"
                    ${currentPage >= totalPages - 1 ? 'disabled' : ''}
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 disabled:cursor-not-allowed rounded text-white text-xs transition-colors"
                  >‚ñ∂</button>
                  <button
                    onclick="state.episodeListPage = ${totalPages - 1}; render();"
                    ${currentPage >= totalPages - 1 ? 'disabled' : ''}
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 disabled:cursor-not-allowed rounded text-white text-xs transition-colors"
                  >‚è≠</button>
                </div>
              ` : ''}
            </div>

            <!-- 3x3 Grid -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-3 max-h-[500px] overflow-y-auto">
              ${visibleEpisodes.map((ep, visibleIdx) => {
                const i = startIdx + visibleIdx;
                return `
                <div
                  onclick="viewEpisode(${i})"
                  class="p-4 rounded-xl border-2 cursor-pointer transition-all transform hover:scale-105 ${
                    i === state.currentEpisodeIndex
                      ? 'bg-gradient-to-br from-pink-500/20 to-purple-500/20 border-pink-500'
                      : state.episodes[i]
                      ? 'bg-green-500/10 border-green-500/50'
                      : 'bg-slate-700/30 border-slate-600 hover:border-slate-500'
                  }"
                >
                  <div class="flex items-start justify-between mb-2">
                    <span class="text-xs font-bold ${
                      i === state.currentEpisodeIndex ? 'text-pink-300' : 'text-slate-400'
                    }">
                      EP ${ep.episode_number}
                    </span>
                    ${state.episodes[i] ? `
                      <span class="text-xs px-2 py-0.5 bg-green-500/20 border border-green-500/50 rounded-full text-green-300 flex items-center gap-1">
                        ‚úÖ Done
                      </span>
                    ` : i === state.currentEpisodeIndex ? `
                      <span class="text-xs px-2 py-0.5 bg-yellow-500/20 border border-yellow-500/50 rounded-full text-yellow-300">
                        ‚è≥ Current
                      </span>
                    ` : `
                      <span class="text-xs px-2 py-0.5 bg-slate-600/50 border border-slate-500/50 rounded-full text-slate-400">
                        üîí Locked
                      </span>
                    `}
                  </div>

                  <h5 class="font-bold text-white text-sm mb-1 line-clamp-1">
                    ${ep.episode_title}
                  </h5>
                  <p class="text-xs text-slate-400 line-clamp-2 mb-2">
                    ${ep.episode_synopsis}
                  </p>

                  ${ep.cliffhanger ? `
                    <div class="mt-2 p-2 bg-red-500/10 border border-red-500/30 rounded">
                      <p class="text-xs text-red-300 line-clamp-1">
                        üî• ${ep.cliffhanger}
                      </p>
                    </div>
                  ` : ''}

                  <!-- Character Focus Badge -->
                  ${ep.character_focus ? `
                    <div class="mt-2 flex items-center gap-1">
                      <span class="text-xs text-slate-500">Focus:</span>
                      <span class="text-xs font-medium text-purple-300 truncate">${ep.character_focus}</span>
                    </div>
                  ` : ''}
                </div>
              `}).join('')}
            </div>

            <!-- Quick Jump -->
            ${totalPages > 5 ? `
              <div class="mt-3 flex items-center gap-2">
                <span class="text-xs text-slate-500">Nh·∫£y ƒë·∫øn:</span>
                <input
                  type="number"
                  min="1"
                  max="${totalEpisodes}"
                  placeholder="S·ªë EP"
                  onchange="const epNum = parseInt(this.value); if (epNum >= 1 && epNum <= ${totalEpisodes}) { state.episodeListPage = Math.floor((epNum - 1) / state.episodesPerPage); render(); }"
                  class="w-20 px-2 py-1 bg-slate-800 border border-slate-600 rounded text-white text-xs focus:outline-none focus:ring-1 focus:ring-purple-500"
                />
              </div>
            ` : ''}
          </div>

          <!-- Current Episode Action Button -->
          ${!state.episodes[state.currentEpisodeIndex] && state.currentStep === 'idle' ? `
            <div class="mt-6">
              <button
                onclick="generateCurrentEpisode()"
                class="w-full py-4 gradient-btn rounded-xl font-bold text-white text-lg transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-3"
              >
                üöÄ T·∫°o Episode ${state.currentEpisodeIndex + 1}: ${state.seriesOutline.episodes[state.currentEpisodeIndex]?.episode_title || 'N/A'}
              </button>
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderNextEpisodeButton() {
      if (state.storyMode !== 'series') return '';
      if (!state.episodes[state.currentEpisodeIndex]) return '';
      if (state.currentEpisodeIndex >= state.episodesPerSeries - 1) return '';

      return `
        <div class="mt-6 glass rounded-2xl p-6 text-center">
          <div class="mb-4">
            <p class="text-slate-400 text-sm mb-2">
              Episode ${state.currentEpisodeIndex + 1} ho√†n th√†nh!
            </p>
            <h4 class="text-xl font-bold text-white mb-2">
              Ti·∫øp t·ª•c v·ªõi Episode ${state.currentEpisodeIndex + 2}
            </h4>
            ${state.seriesOutline?.episodes[state.currentEpisodeIndex + 1] ? `
              <p class="text-sm text-slate-300">
                "${state.seriesOutline.episodes[state.currentEpisodeIndex + 1].episode_title}"
              </p>
            ` : ''}
          </div>

          <button
            onclick="nextEpisode()"
            class="px-8 py-4 bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-600 hover:to-blue-600 rounded-xl font-bold text-white text-lg transition-all transform hover:scale-105 active:scale-95 flex items-center justify-center gap-3 mx-auto"
          >
            <span class="text-2xl">‚ñ∂Ô∏è</span>
            Ti·∫øp t·ª•c Episode ${state.currentEpisodeIndex + 2}
            <span class="text-2xl">üé¨</span>
          </button>

          <p class="text-xs text-slate-500 mt-3">
            ${state.episodesPerSeries - state.currentEpisodeIndex - 1} episodes c√≤n l·∫°i
          </p>
        </div>
      `;
    }

    function renderSeriesComplete() {
      if (state.storyMode !== 'series') return '';
      if (state.currentEpisodeIndex !== state.episodesPerSeries - 1) return '';
      if (!state.episodes[state.currentEpisodeIndex]) return '';

      return `
        <div class="mt-6 glass rounded-2xl p-8 text-center border-2 border-green-500/50">
          <div class="text-6xl mb-4">üéâ</div>
          <h3 class="text-3xl font-black text-white mb-2">
            Series Ho√†n Th√†nh!
          </h3>
          <p class="text-slate-300 mb-4">
            B·∫°n ƒë√£ t·∫°o th√†nh c√¥ng <span class="text-yellow-300 font-bold">${state.episodesPerSeries} episodes</span>
            v·ªõi t·ªïng <span class="text-cyan-300 font-bold">${state.episodes.reduce((sum, ep) => sum + (ep?.panels?.length || 0), 0)} panels</span>!
          </p>

          <div class="flex gap-3 justify-center">
            <button
              onclick="downloadAllPanels()"
              class="px-6 py-3 bg-gradient-to-r from-green-500 to-cyan-500 hover:from-green-600 hover:to-cyan-600 rounded-xl font-bold text-white flex items-center gap-2"
            >
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
              </svg>
              T·∫£i To√†n B·ªô Series
            </button>

            <button
              onclick="state.storyMode = 'single'; state.seriesOutline = null; state.episodes = []; state.currentEpisodeIndex = 0; state.panels = []; state.storyData = null; render();"
              class="px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-xl font-medium text-white"
            >
              üîÑ T·∫°o Series M·ªõi
            </button>
          </div>
        </div>
      `;
    }

    function renderStoryInfo() {
      return `
        <div class="glass rounded-2xl p-6">
          <div class="flex items-start justify-between mb-4">
            <div class="flex-1">
              <h3 class="text-2xl font-bold text-white mb-2">${state.storyData.title}</h3>
              <p class="text-slate-300 text-sm mb-2">${state.storyData.synopsis}</p>
              ${state.storyData.theme ? `
                <p class="text-xs text-slate-400 italic">
                  <span class="text-purple-400">‚ú® Theme:</span> ${state.storyData.theme}
                </p>
              ` : ''}
            </div>
            <div class="flex gap-2 flex-shrink-0">
              <button
                onclick="downloadAllPanels()"
                class="px-4 py-2 bg-gradient-to-r from-green-500/20 to-cyan-500/20 hover:from-green-500/30 hover:to-cyan-500/30 border border-green-500/50 rounded-lg text-green-300 text-sm font-medium transition-all flex items-center gap-2 transform hover:scale-105"
                title="T·∫£i t·∫•t c·∫£ panels v·ªÅ m√°y d∆∞·ªõi d·∫°ng file ZIP"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                </svg>
                T·∫£i t·∫•t c·∫£
              </button>
              <button
                onclick="exportPanels()"
                class="px-4 py-2 bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-500/50 rounded-lg text-cyan-300 text-sm font-medium transition-colors"
                title="Export d·ªØ li·ªáu truy·ªán"
              >
                üì• Export
              </button>
            </div>
          </div>

          ${state.storyData.characters?.length > 0 ? `
            <div class="mt-4 pt-4 border-t border-slate-600">
              <h4 class="text-xs font-semibold text-slate-400 mb-2">NH√ÇN V·∫¨T:</h4>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                ${state.storyData.characters.map(char => `
                  <div class="p-3 bg-slate-700/50 rounded-lg">
                    <div class="flex items-center gap-2 mb-1">
                      <span class="font-bold text-white">${char.name}</span>
                      ${char.role ? `
                        <span class="px-2 py-0.5 bg-purple-500/20 border border-purple-500/30 rounded-full text-xs text-purple-300">
                          ${char.role}
                        </span>
                      ` : ''}
                    </div>
                    ${char.personality ? `
                      <p class="text-xs text-slate-400 mb-1">${char.personality}</p>
                    ` : ''}
                    ${char.visual_description ? `
                      <p class="text-xs text-slate-500 line-clamp-2">${char.visual_description}</p>
                    ` : ''}
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderPanelsGrid() {
      return `
        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
          ${state.panels.map((panel, index) => `
            <div class="glass rounded-2xl overflow-hidden panel-card group">
              <div class="aspect-[9/16] relative bg-slate-900/50">
                ${panel.loading ? `
                  <div class="absolute inset-0 flex items-center justify-center">
                    <div class="loading-spinner"></div>
                  </div>
                ` : panel.imageData ? `
                  <img
                    src="${panel.imageData}"
                    alt="Panel ${panel.panelNum}"
                    class="w-full h-full object-cover cursor-pointer"
                    onclick="downloadImage('${panel.imageData}', ${panel.panelNum})"
                  />
                ` : panel.error ? `
                  <div class="absolute inset-0 flex flex-col items-center justify-center p-4 text-center">
                    <span class="text-4xl mb-2">‚ö†Ô∏è</span>
                    <p class="text-red-300 text-xs">${panel.error}</p>
                    <button
                      onclick="openRegenerateModal(${index})"
                      class="mt-3 px-4 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg text-purple-300 text-xs font-medium"
                    >
                      üîÑ Th·ª≠ l·∫°i
                    </button>
                  </div>
                ` : ''}
                
                <!-- Panel number badge -->
                <div class="absolute top-2 left-2 w-8 h-8 bg-black/60 backdrop-blur-sm rounded-full flex items-center justify-center">
                  <span class="text-white text-sm font-bold">${panel.panelNum}</span>
                </div>

                <!-- Ad panel indicator -->
                ${panel.panelData?.is_ad_panel ? `
                  <div class="absolute top-2 left-12 px-2 py-1 bg-gradient-to-r from-yellow-500/90 to-orange-500/90 backdrop-blur-sm rounded-full flex items-center gap-1">
                    <span class="text-white text-xs font-bold">üì¢ AD</span>
                  </div>
                ` : ''}

                <!-- Regenerate button -->
                ${panel.imageData && !panel.loading ? `
                  <button
                    onclick="openRegenerateModal(${index})"
                    class="regenerate-btn absolute top-2 right-2 w-8 h-8 bg-black/60 backdrop-blur-sm rounded-full flex items-center justify-center opacity-0 transition-opacity hover:bg-black/80"
                    title="T·∫°o l·∫°i panel n√†y"
                  >
                    <span class="text-white text-sm">üîÑ</span>
                  </button>
                ` : ''}
              </div>
              
              <!-- Panel info -->
              <div class="p-3">
                ${panel.modification ? `
                  <div class="mb-2 p-2 bg-purple-500/20 border border-purple-500/30 rounded-lg">
                    <p class="text-xs text-purple-300 mb-1 font-semibold">‚ú® ƒê√£ s·ª≠a:</p>
                    <p class="text-xs text-purple-200">${panel.modification}</p>
                  </div>
                ` : ''}
                ${panel.panelData?.dialogue ? `
                  <p class="text-white text-sm font-medium mb-1">
                    üí¨ ${stripCharacterName(panel.panelData.dialogue)}
                  </p>
                ` : ''}
                ${panel.panelData?.narration ? `
                  <p class="text-slate-400 text-xs italic">
                    üìù ${panel.panelData.narration}
                  </p>
                ` : ''}
                ${panel.panelData?.mood ? `
                  <span class="inline-block mt-2 px-2 py-0.5 bg-slate-700 rounded-full text-xs text-slate-300">
                    ${panel.panelData.mood}
                  </span>
                ` : ''}
              </div>
            </div>
          `).join('')}
        </div>
      `;
    }

    function renderEmptyState() {
      return `
        <div class="glass rounded-2xl p-12 border border-dashed border-slate-600 text-center">
          <div class="text-6xl mb-4">üì±‚ú®</div>
          <h3 class="text-xl font-bold text-white mb-2">
            S·∫µn s√†ng t·∫°o truy·ªán tranh ho√†n ch·ªânh!
          </h3>
          <p class="text-slate-400 max-w-md mx-auto mb-4">
            Ch·ªçn th·ªÉ lo·∫°i, ƒë·ªô d√†i, c∆∞·ªùng ƒë·ªô c·∫£m x√∫c. AI s·∫Ω t·ª± ƒë·ªông t·∫°o nh√¢n v·∫≠t,
            vi·∫øt c·ªët truy·ªán c√≥ beginning-middle-end, v√† v·∫Ω t·ª´ng panel v·ªõi speech bubbles.
          </p>
          <div class="grid grid-cols-2 gap-4 max-w-sm mx-auto mt-6 text-left">
            <div class="p-3 bg-slate-700/30 rounded-lg">
              <div class="text-2xl mb-1">ü§ñ</div>
              <p class="text-xs text-slate-300 font-medium">DeepSeek AI</p>
              <p class="text-xs text-slate-500">Story structure & dialogue</p>
            </div>
            <div class="p-3 bg-slate-700/30 rounded-lg">
              <div class="text-2xl mb-1">üé®</div>
              <p class="text-xs text-slate-300 font-medium">Gemini 2.0</p>
              <p class="text-xs text-slate-500">Professional comic art</p>
            </div>
          </div>
        </div>
      `;
    }

    // Check if API keys exist
    if (state.deepseekKey && state.geminiKey) {
      state.showApiSetup = false;
    }

    // Initial render
    render();
  </script>
</body>
</html>
